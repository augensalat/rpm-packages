Index: VERSION
===================================================================
--- VERSION	(.../trunk)	(Revision 1)
+++ VERSION	(.../branches/bulkmailer)	(Revision 29)
@@ -1 +1 @@
-qmail 1.03
+netqmail 1.05
Index: qmail-smtpd.8
===================================================================
--- qmail-smtpd.8	(.../trunk)	(Revision 1)
+++ qmail-smtpd.8	(.../branches/bulkmailer)	(Revision 29)
@@ -169,6 +169,20 @@
 .B qmail-smtpd
 will wait for each new buffer of data from the remote SMTP client.
 Default: 1200.
+.SH "ENVIRONMENT VARIABLES"
+.TP 5
+.I CHKRCPT
+If set to 1
+.B qmail-smtpd
+rejects messages in SMTP dialogue when there is no local recipient.
+.TP 5
+.I DATABYTES
+see
+.BR "CONTROL FILES - databytes"
+.TP 5
+.I RELAYCLIENT
+see
+.BR "CONTROL FILES - rcpthosts"
 .SH "SEE ALSO"
 tcp-env(1),
 tcp-environ(5),
Index: qmail-pop3d.c
===================================================================
--- qmail-pop3d.c	(.../trunk)	(Revision 1)
+++ qmail-pop3d.c	(.../branches/bulkmailer)	(Revision 29)
@@ -66,14 +66,14 @@
 void die_scan() { err("unable to scan $HOME/Maildir"); die(); }
 
 void err_syntax() { err("syntax error"); }
-void err_unimpl() { err("unimplemented"); }
+void err_unimpl(arg) char *arg; { err("unimplemented"); }
 void err_deleted() { err("already deleted"); }
 void err_nozero() { err("messages are counted from 1"); }
 void err_toobig() { err("not that many messages"); }
 void err_nosuch() { err("unable to open that message"); }
 void err_nounlink() { err("unable to unlink all deleted messages"); }
 
-void okay() { puts("+OK \r\n"); flush(); }
+void okay(arg) char *arg; { puts("+OK \r\n"); flush(); }
 
 void printfn(fn) char *fn;
 {
@@ -146,30 +146,30 @@
   }
 }
 
-void pop3_stat()
+void pop3_stat(arg) char *arg;
 {
-  int i;
+  int i, j=0;
   unsigned long total;
  
   total = 0;
-  for (i = 0;i < numm;++i) if (!m[i].flagdeleted) total += m[i].size;
+  for (i = 0;i < numm;++i) if (!m[i].flagdeleted) { total += m[i].size; j++; }
   puts("+OK ");
-  put(strnum,fmt_uint(strnum,numm));
+  put(strnum,fmt_uint(strnum,j));
   puts(" ");
   put(strnum,fmt_ulong(strnum,total));
   puts("\r\n");
   flush();
 }
 
-void pop3_rset()
+void pop3_rset(arg) char *arg;
 {
   int i;
   for (i = 0;i < numm;++i) m[i].flagdeleted = 0;
   last = 0;
-  okay();
+  okay(0);
 }
 
-void pop3_last()
+void pop3_last(arg) char *arg;
 {
   puts("+OK ");
   put(strnum,fmt_uint(strnum,last));
@@ -177,7 +177,7 @@
   flush();
 }
 
-void pop3_quit()
+void pop3_quit(arg) char *arg;
 {
   int i;
   for (i = 0;i < numm;++i)
@@ -192,7 +192,7 @@
 	if (!stralloc_0(&line)) die_nomem();
 	rename(m[i].fn,line.s); /* if it fails, bummer */
       }
-  okay();
+  okay(0);
   die();
 }
 
@@ -214,7 +214,7 @@
   if (i == -1) return;
   m[i].flagdeleted = 1;
   if (i + 1 > last) last = i + 1;
-  okay();
+  okay(0);
 }
 
 void list(i,flaguidl)
@@ -238,7 +238,7 @@
     list(i,flaguidl);
   }
   else {
-    okay();
+    okay(0);
     for (i = 0;i < numm;++i)
       if (!m[i].flagdeleted)
 	list(i,flaguidl);
@@ -267,7 +267,7 @@
  
   fd = open_read(m[i].fn);
   if (fd == -1) { err_nosuch(); return; }
-  okay();
+  okay(0);
   substdio_fdbuf(&ssmsg,read,fd,ssmsgbuf,sizeof(ssmsgbuf));
   blast(&ssmsg,limit);
   close(fd);
@@ -299,7 +299,7 @@
  
   getlist();
 
-  okay();
+  okay(0);
   commands(&ssin,pop3commands);
   die();
 }
Index: README.patches
===================================================================
--- README.patches	(.../trunk)	(Revision 0)
+++ README.patches	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,61 @@
+The following patches have been applied to standard qmail-1.03:
+
+- netqmail-1.05 which incorporates
+  * errno patch for qmail to work with current glibcs
+  * qmail_local patch (Erik Sjölund)
+    http://www.ornl.gov/lists/mailing-lists/qmail/2000/10/msg00696.html
+  * qmail-0.0.0.0.patch (Scott Gifford)
+    recognize 0.0.0.0 as a local IP address
+  * sendmail-flagf.patch (David Phillips)
+    sendmail's -f option sets a default From: header
+  * qmailqueue-patch (Bruce Guenter)
+    Causes any program that would run qmail-queue to look for an
+    environment variable QMAILQUEUE. If it is present, it is used in
+    place of the string "bin/qmail-queue" when running qmail-queue.
+    This could be used, for example, to add a program into the
+    qmail-smtpd->qmail-queue pipeline that could do filtering, rewrite
+    broken headers, etc.
+
+- silly qmail syndrome patch: ext_todo-20030105 (Claudio Jeker and
+  Andre Oppermann)
+
+- install-path.patch and autouidgid.patch (Bruce Guenter)
+  Get userids by looking at files in /var/qmail/owners.
+
+- big-concurrency.patch (Johannes Erdfelt)
+  Allow qmail to use a concurrency greater than 240.
+
+- qmail-mime.patch (Fred Lindberg)
+  Causes qmail-send to preserve the MIME-ness when bouncing MIME messages.
+
+- qmail-1.03-pop3d-stat.patch (I. Dwayne Koonce)
+  Fixes the stat command in qmail-pop3d.
+
+- qmtpd-badmailfrom patch (Peter van Dijk)
+  Make qmtpd consider badmailfrom.
+
+- smtpd-502-to-500 patch (J. de Boyne Pollard)
+  Modifies the behaviour of qmail-smtpd so that it responds with a 500
+  error code to unrecognised SMTP commands instead of a 502 error code.
+
+- smtpd-logging patch (Bernhard Graf)
+  Add logging to qmail-smtpd.
+
+- qmail-smtpd size patch (Will Harris, Erwin Hoffmann)
+  RFC 1870 compliance patch: support ESMTP SIZE parameter
+
+- big-todo.patch (Russell Nelson, Dave Smith, Andreas Aardal Hanssen)
+  Useful if you need to inject big quantaties of emails into the queue.
+
+- random_ip_bind.patch (Bernhard Graf)
+  Facility to randomly bind to one of a list of local ip addresses.
+  This deals with grey listing techniques blocking ip sources that send
+  a certain volume of emails within a time frame.
+
+- qmail-realrcptto patch (Paul Jarc)
+  Reject receipt in smtp/qmtp phase if no matching .qmail file exists.
+  Patch is slightly modified
+  - you have to set environment variable CHKRCPT=1 to enable it.
+  - logging in realrcpto.c is disabled - it's redundant to smtpd-logging patch
+    
+
Index: qmail.c
===================================================================
--- qmail.c	(.../trunk)	(Revision 1)
+++ qmail.c	(.../branches/bulkmailer)	(Revision 29)
@@ -6,15 +6,26 @@
 #include "fd.h"
 #include "qmail.h"
 #include "auto_qmail.h"
+#include "env.h"
 
-static char *binqqargs[2] = { "bin/qmail-queue", 0 } ;
+static char *binqqargs[2] = { 0, 0 } ;
 
+static void setup_qqargs()
+{
+  if(!binqqargs[0])
+    binqqargs[0] = env_get("QMAILQUEUE");
+  if(!binqqargs[0])
+    binqqargs[0] = "bin/qmail-queue";
+}
+
 int qmail_open(qq)
 struct qmail *qq;
 {
   int pim[2];
   int pie[2];
 
+  setup_qqargs();
+
   if (pipe(pim) == -1) return -1;
   if (pipe(pie) == -1) { close(pim[0]); close(pim[1]); return -1; }
  
Index: qmail-popup.c
===================================================================
--- qmail-popup.c	(.../trunk)	(Revision 1)
+++ qmail-popup.c	(.../branches/bulkmailer)	(Revision 29)
@@ -64,10 +64,10 @@
 
 void err_syntax() { err("syntax error"); }
 void err_wantuser() { err("USER first"); }
-void err_authoriz() { err("authorization first"); }
+void err_authoriz(arg) char *arg; { err("authorization first"); }
 
-void okay() { puts("+OK \r\n"); flush(); }
-void pop3_quit() { okay(); die(); }
+void okay(arg) char *arg; { puts("+OK \r\n"); flush(); }
+void pop3_quit(arg) char *arg; { okay(0); die(); }
 
 
 char unique[FMT_ULONG + FMT_ULONG + 3];
@@ -136,7 +136,7 @@
 void pop3_user(arg) char *arg;
 {
   if (!*arg) { err_syntax(); return; }
-  okay();
+  okay(0);
   seenuser = 1;
   if (!stralloc_copys(&username,arg)) die_nomem(); 
   if (!stralloc_0(&username)) die_nomem(); 
Index: qmail-queue.8
===================================================================
--- qmail-queue.8	(.../trunk)	(Revision 1)
+++ qmail-queue.8	(.../branches/bulkmailer)	(Revision 29)
@@ -40,6 +40,12 @@
 However, the recipients probably expect to see a proper header,
 as described in
 .BR qmail-header(5) .
+
+Programs included with qmail which invoke
+.B qmail-queue
+will invoke the contents of
+.B $QMAILQUEUE
+instead, if that environment variable is set.
 .SH "FILESYSTEM RESTRICTIONS"
 .B qmail-queue
 imposes two constraints on the queue structure:
Index: qmail-smtpd.c
===================================================================
--- qmail-smtpd.c	(.../trunk)	(Revision 1)
+++ qmail-smtpd.c	(.../branches/bulkmailer)	(Revision 29)
@@ -1,3 +1,4 @@
+#include <sys/types.h>
 #include "sig.h"
 #include "readwrite.h"
 #include "stralloc.h"
@@ -23,10 +24,12 @@
 #include "timeoutread.h"
 #include "timeoutwrite.h"
 #include "commands.h"
+#include "strerr.h"
 
 #define MAXHOPS 100
 unsigned int databytes = 0;
 int timeout = 1200;
+char strpid[FMT_ULONG];
 
 int safewrite(fd,buf,len) int fd; char *buf; int len;
 {
@@ -43,22 +46,79 @@
 void out(s) char *s; { substdio_puts(&ssout,s); }
 
 void die_read() { _exit(1); }
-void die_alarm() { out("451 timeout (#4.4.2)\r\n"); flush(); _exit(1); }
+void die_alarm() {
+  out("451 timeout (#4.4.2)\r\n"); flush();
+  strerr_warn3("qmail-smtpd[",strpid,"]: 451 timeout",0);
+  _exit(1);
+}
 void die_nomem() { out("421 out of memory (#4.3.0)\r\n"); flush(); _exit(1); }
-void die_control() { out("421 unable to read controls (#4.3.0)\r\n"); flush(); _exit(1); }
-void die_ipme() { out("421 unable to figure out my IP addresses (#4.3.0)\r\n"); flush(); _exit(1); }
-void straynewline() { out("451 See http://pobox.com/~djb/docs/smtplf.html.\r\n"); flush(); _exit(1); }
+void die_control() {
+  out("421 unable to read controls (#4.3.0)\r\n"); flush();
+  strerr_warn3("qmail-smtpd[",strpid,"]: 421 unable to read controls",0);
+  _exit(1);
+}
+void die_ipme() {
+  out("421 unable to figure out my IP addresses (#4.3.0)\r\n"); flush();
+  strerr_warn3("qmail-smtpd[",strpid,"]: 421 unable to figure out my IP addresses",0);
+  _exit(1);
+}
+void die_cdb() {
+  out("421 unable to read cdb user database (#4.3.0)\r\n"); flush();
+  strerr_warn3("qmail-smtpd[",strpid,"]: 421 unable to read cdb user database",0);
+  _exit(1);
+}
+void die_sys() {
+  out("421 unablRe to read system user database (#4.3.0)\r\n"); flush();
+  strerr_warn3("qmail-smtpd[",strpid,"]: 421 unable to read system user database",0);
+  _exit(1);
+}
+void straynewline() {
+  out("451 See http://pobox.com/~djb/docs/smtplf.html.\r\n"); flush();
+  strerr_warn3("qmail-smtpd[",strpid,"]: 451 See http://pobox.com/~djb/docs/smtplf.html",0);
+  _exit(1);
+}
 
-void err_bmf() { out("553 sorry, your envelope sender is in my badmailfrom list (#5.7.1)\r\n"); }
-void err_nogateway() { out("553 sorry, that domain isn't in my list of allowed rcpthosts (#5.7.1)\r\n"); }
-void err_unimpl() { out("502 unimplemented (#5.5.1)\r\n"); }
-void err_syntax() { out("555 syntax error (#5.5.4)\r\n"); }
-void err_wantmail() { out("503 MAIL first (#5.5.1)\r\n"); }
-void err_wantrcpt() { out("503 RCPT first (#5.5.1)\r\n"); }
-void err_noop() { out("250 ok\r\n"); }
-void err_vrfy() { out("252 send some mail, i'll try my best\r\n"); }
-void err_qqt() { out("451 qqt failure (#4.3.0)\r\n"); }
+void err_bmf() {
+  out("553 sorry, your envelope sender is in my badmailfrom list (#5.7.1)\r\n");
+  strerr_warn3("qmail-smtpd[",strpid,"]: 553 sorry, your envelope sender is in my badmailfrom list",0);
+}
+void err_nogateway() {
+  out("553 sorry, that domain isn't in my list of allowed rcpthosts (#5.7.1)\r\n");
+  strerr_warn3("qmail-smtpd[",strpid,"]: 553 sorry, that domain isn't in my list of allowed rcpthosts",0);
+}
+void err_unimpl(arg) char *arg; { out("502 unimplemented (#5.5.1)\r\n"); }
+void err_unrecog(arg) char *arg; { out("500 unrecognised (#5.5.2)\r\n"); }
+void err_size() {
+    out("552 sorry, that message size exceeds my databytes limit (#5.3.4)\r\n");
+    strerr_warn3("qmail-smtpd[",strpid,"]: 552 sorry, that message size exceeds my databytes limit",0);
+}
+void err_syntax() {
+  out("555 syntax error (#5.5.4)\r\n");
+  strerr_warn3("qmail-smtpd[",strpid,"]: 555 syntax error",0);
+}
+void err_wantmail() {
+  out("503 MAIL first (#5.5.1)\r\n");
+  strerr_warn3("qmail-smtpd[",strpid,"]: 503 MAIL first",0);
+}
+void err_wantrcpt() {
+  out("503 RCPT first (#5.5.1)\r\n");
+  strerr_warn3("qmail-smtpd[",strpid,"]: 503 RCPT first",0);
+}
+void err_nomailbox() {
+    out("550 sorry, no mailbox here by that name. (#5.1.1)\r\n");
+    strerr_warn3("qmail-smtpd[",strpid,"]: 550 sorry, no mailbox here by that name.",0);
+}
+void err_noop(arg) char *arg; { out("250 ok\r\n"); }
+void err_vrfy(arg) char *arg; { out("252 send some mail, i'll try my best\r\n"); }
+void err_qqt() {
+  out("451 qqt failure (#4.3.0)\r\n");
+  strerr_warn3("qmail-smtpd[",strpid,"]: 451 qqt failure",0);
+}
 
+extern void realrcptto_init();
+extern void realrcptto_start();
+extern int realrcptto();
+extern int realrcptto_deny();
 
 stralloc greeting = {0};
 
@@ -67,11 +127,11 @@
   substdio_puts(&ssout,code);
   substdio_put(&ssout,greeting.s,greeting.len);
 }
-void smtp_help()
+void smtp_help(arg) char *arg;
 {
-  out("214 qmail home page: http://pobox.com/~djb/qmail.html\r\n");
+  out("214 netqmail home page: http://qmail.org/netqmail\r\n");
 }
-void smtp_quit()
+void smtp_quit(arg) char *arg;
 {
   smtp_greet("221 "); out("\r\n"); flush(); _exit(0);
 }
@@ -117,6 +177,8 @@
   if (bmfok)
     if (!constmap_init(&mapbmf,bmf.s,bmf.len,0)) die_nomem();
  
+  realrcptto_init();
+
   if (control_readint(&databytes,"control/databytes") == -1) die_control();
   x = env_get("DATABYTES");
   if (x) { scan_ulong(x,&u); databytes = u; }
@@ -197,6 +259,43 @@
   return 1;
 }
 
+int sizelimit(arg) /* modified SIZELIMIT function by Erwin Hoffmann (tx Uwe Ohse) */
+char *arg;   
+{
+  int i;
+  long r;
+  char terminator;
+  unsigned long sizebytes = 0;
+
+  terminator = '>';
+  i = str_chr(arg,'<');
+  if (arg[i])
+    arg += i + 1;
+  else {
+    terminator = ' ';
+    arg += str_chr(arg,':');
+    if (*arg == ':') ++arg;
+    while (*arg == ' ') ++arg;
+  }
+
+  arg += str_chr(arg,terminator);
+  if (*arg && terminator == '>' ) ++arg; /* end of adddress */
+
+  while (*++arg) {
+    i = str_chr(arg,'=');
+    arg[i] = 0;
+    if (case_equals(arg,"SIZE")) {
+      arg += i + 1;
+      scan_ulong(arg,&sizebytes);
+      r = databytes - sizebytes;
+      if (r < 0) return 0;
+    }
+    else
+      ++arg;
+  }
+  return 1;
+}
+
 int bmfcheck()
 {
   int j;
@@ -229,25 +328,33 @@
 }
 void smtp_ehlo(arg) char *arg;
 {
-  smtp_greet("250-"); out("\r\n250-PIPELINING\r\n250 8BITMIME\r\n");
+  char size_buf[FMT_ULONG];
+  size_buf[fmt_ulong(size_buf,(unsigned long) databytes)] = 0;
+  smtp_greet("250-");
+  out("\r\n250-SIZE "); out(size_buf);
+  out("\r\n250-PIPELINING\r\n250 8BITMIME\r\n");
   seenmail = 0; dohelo(arg);
 }
-void smtp_rset()
+void smtp_rset(arg) char *arg;
 {
   seenmail = 0;
   out("250 flushed\r\n");
 }
 void smtp_mail(arg) char *arg;
 {
+  strerr_warn4("qmail-smtpd[",strpid,"]: MAIL ",arg,0);
   if (!addrparse(arg)) { err_syntax(); return; }
+  if (databytes && !sizelimit(arg)) { err_size(); return; }
   flagbarf = bmfcheck();
   seenmail = 1;
   if (!stralloc_copys(&rcptto,"")) die_nomem();
   if (!stralloc_copys(&mailfrom,addr.s)) die_nomem();
   if (!stralloc_0(&mailfrom)) die_nomem();
+  realrcptto_start();
   out("250 ok\r\n");
 }
 void smtp_rcpt(arg) char *arg; {
+  strerr_warn4("qmail-smtpd[",strpid,"]: RCPT ",arg,0);
   if (!seenmail) { err_wantmail(); return; }
   if (!addrparse(arg)) { err_syntax(); return; }
   if (flagbarf) { err_bmf(); return; }
@@ -258,6 +365,7 @@
   }
   else
     if (!addrallowed()) { err_nogateway(); return; }
+  if (!realrcptto(addr.s)) { err_nomailbox(); return; }
   if (!stralloc_cats(&rcptto,"T")) die_nomem();
   if (!stralloc_cats(&rcptto,addr.s)) die_nomem();
   if (!stralloc_0(&rcptto)) die_nomem();
@@ -316,8 +424,8 @@
         if (flagmaybex) if (pos == 7) ++*hops;
         if (pos < 2) if (ch != "\r\n"[pos]) flagmaybey = 0;
         if (flagmaybey) if (pos == 1) flaginheader = 0;
+	++pos;
       }
-      ++pos;
       if (ch == '\n') { pos = 0; flagmaybex = flagmaybey = flagmaybez = 1; }
     }
     switch(state) {
@@ -363,15 +471,17 @@
   accept_buf[fmt_ulong(accept_buf,qp)] = 0;
   out(accept_buf);
   out("\r\n");
+  strerr_warn4("qmail-smtpd[",strpid,"]: Accepted messages qp ",accept_buf,0);
 }
 
-void smtp_data() {
+void smtp_data(arg) char *arg; {
   int hops;
   unsigned long qp;
   char *qqx;
  
   if (!seenmail) { err_wantmail(); return; }
   if (!rcptto.len) { err_wantrcpt(); return; }
+  if (realrcptto_deny()) { err_nomailbox(); return; }
   seenmail = 0;
   if (databytes) bytestooverflow = databytes + 1;
   if (qmail_open(&qqt) == -1) { err_qqt(); return; }
@@ -387,11 +497,20 @@
  
   qqx = qmail_close(&qqt);
   if (!*qqx) { acceptmessage(qp); return; }
-  if (hops) { out("554 too many hops, this message is looping (#5.4.6)\r\n"); return; }
-  if (databytes) if (!bytestooverflow) { out("552 sorry, that message size exceeds my databytes limit (#5.3.4)\r\n"); return; }
-  if (*qqx == 'D') out("554 "); else out("451 ");
-  out(qqx + 1);
-  out("\r\n");
+  if (hops) {
+    out("554 too many hops, this message is looping (#5.4.6)\r\n");
+    strerr_warn3("qmail-smtpd[",strpid,"]: 554 too many hops, this message is looping",0);
+    return;
+  }
+  if (databytes) if (!bytestooverflow) { err_size(); return; }
+  if (*qqx == 'D') {
+    out("554 "); out(qqx + 1); out("\r\n");
+    strerr_warn4("qmail-smtpd[",strpid,"]: 554 ",qqx + 1,0);
+  }
+  else {
+    out("451 "); out(qqx + 1); out("\r\n");
+    strerr_warn4("qmail-smtpd[",strpid,"]: 451 ",qqx + 1,0);
+  }
 }
 
 struct commands smtpcommands[] = {
@@ -405,12 +524,13 @@
 , { "help", smtp_help, flush }
 , { "noop", err_noop, flush }
 , { "vrfy", err_vrfy, flush }
-, { 0, err_unimpl, flush }
+, { 0, err_unrecog, flush }
 } ;
 
 void main()
 {
   sig_pipeignore();
+  strpid[fmt_ulong(strpid, (unsigned long) getpid())] = 0;
   if (chdir(auto_qmail) == -1) die_control();
   setup();
   if (ipme_init() != 1) die_ipme();
Index: sendmail.c
===================================================================
--- sendmail.c	(.../trunk)	(Revision 1)
+++ sendmail.c	(.../branches/bulkmailer)	(Revision 29)
@@ -45,6 +45,38 @@
   _exit(111);
 }
 
+void do_sender(s)
+const char *s;
+{
+  char *x;
+  int n;
+  int a;
+  int i;
+  
+  env_unset("QMAILNAME");
+  env_unset("MAILNAME");
+  env_unset("NAME");
+  env_unset("QMAILHOST");
+  env_unset("MAILHOST");
+
+  n = str_len(s);
+  a = str_rchr(s, '@');
+  if (a == n)
+  {
+    env_put2("QMAILUSER", s);
+    return;
+  }
+  env_put2("QMAILHOST", s + a + 1);
+
+  x = (char *) alloc((a + 1) * sizeof(char));
+  if (!x) nomem();
+  for (i = 0; i < a; i++)
+    x[i] = s[i];
+  x[i] = 0;
+  env_put2("QMAILUSER", x);
+  alloc_free(x);
+}
+
 int flagh;
 char *sender;
 
@@ -118,6 +150,7 @@
   if (sender) {
     *arg++ = "-f";
     *arg++ = sender;
+    do_sender(sender);
   }
   *arg++ = "--";
   for (i = 0;i < argc;++i) *arg++ = argv[i];
Index: qmail-queue.c
===================================================================
--- qmail-queue.c	(.../trunk)	(Revision 1)
+++ qmail-queue.c	(.../branches/bulkmailer)	(Revision 29)
@@ -73,11 +73,11 @@
  i = fmt_str(s,"Received: (qmail "); len += i; if (s) s += i;
  i = fmt_ulong(s,mypid); len += i; if (s) s += i;
  i = fmt_str(s," invoked "); len += i; if (s) s += i;
- if (uid == auto_uida)
+ if (uid == get_uid(auto_uida))
   { i = fmt_str(s,"by alias"); len += i; if (s) s += i; }
- else if (uid == auto_uidd)
+ else if (uid == get_uid(auto_uidd))
   { i = fmt_str(s,"from network"); len += i; if (s) s += i; }
- else if (uid == auto_uids)
+ else if (uid == get_uid(auto_uids))
   { i = fmt_str(s,"for bounce"); len += i; if (s) s += i; }
  else
   {
@@ -180,8 +180,8 @@
 
  messnum = pidst.st_ino;
  messfn = fnnum("mess/",1);
- todofn = fnnum("todo/",0);
- intdfn = fnnum("intd/",0);
+ todofn = fnnum("todo/",1);
+ intdfn = fnnum("intd/",1);
 
  if (link(pidfn,messfn) == -1) die(64);
  if (unlink(pidfn) == -1) die(63);
Index: INSTALL
===================================================================
--- INSTALL	(.../trunk)	(Revision 1)
+++ INSTALL	(.../branches/bulkmailer)	(Revision 29)
@@ -1,84 +1,2 @@
-SAVE COPIES OF YOUR OUTGOING MAIL! Like any other piece of software (and
-information generally), the qmail system comes with NO WARRANTY. It's
-much more secure and reliable than sendmail, but that's not saying much.
-
-
-Things you have to decide before starting:
-
-* The qmail home directory, normally /var/qmail. To change this
-directory, edit conf-qmail now.
-
-* The names of the qmail users and the qmail groups. To change these
-names, edit conf-users and conf-groups now.
-
-
-To create /var/qmail and configure qmail (won't interfere with sendmail):
-
- 1. Create the qmail home directory:
-       # mkdir /var/qmail
-
- 2. Read INSTALL.ids. You must set up the qmail group and the qmail
-    users before compiling the programs.
-
- 3. Compile the programs and create the qmail directory tree:
-       # make setup check
-
- 4. Read INSTALL.ctl and FAQ. Minimal survival command:
-       # ./config
-
- 5. Read INSTALL.alias. Minimal survival command:
-       # (cd ~alias; touch .qmail-postmaster .qmail-mailer-daemon .qmail-root)
-       # chmod 644 ~alias/.qmail*
-
- 6. Read INSTALL.mbox and INSTALL.vsm.
-
- 7. Read INSTALL.maildir.
-
- 8. Copy /var/qmail/boot/home (or proc) to /var/qmail/rc.
-
-
-To test qmail deliveries (won't interfere with sendmail):
-
- 9. Enable deliveries of messages injected into qmail:
-       # csh -cf '/var/qmail/rc &'
-
-10. Read TEST.deliver.
-
-
-To upgrade from sendmail to qmail:
-
-11. Read SENDMAIL. This is what your users will want to know about the
-    switch from sendmail to qmail.
-
-12. Read REMOVE.sendmail. You must remove sendmail before installing
-    qmail.
-
-13. Read REMOVE.binmail.
-
-14. Add
-            csh -cf '/var/qmail/rc &'
-    to your boot scripts, so that the qmail daemons are restarted
-    whenever your system reboots. Make sure you include the &.
-
-15. Make qmail's ``sendmail'' wrapper available to MUAs:
-       # ln -s /var/qmail/bin/sendmail /usr/lib/sendmail
-       # ln -s /var/qmail/bin/sendmail /usr/sbin/sendmail
-    /usr/sbin might not exist on your system.
-
-16. Set up qmail-smtpd in /etc/inetd.conf (all on one line):
-            smtp stream tcp nowait qmaild /var/qmail/bin/tcp-env
-            tcp-env /var/qmail/bin/qmail-smtpd
-
-17. Reboot. (Or kill -HUP your inetd and make sure the qmail daemons
-    are running.)
-
-18. Read TEST.receive.
-
-
-
-That's it! To report success:
-       % ( echo 'First M. Last'; cat `cat SYSDEPS` ) | mail djb-qst@cr.yp.to
-Replace First M. Last with your name.
-
-If you have questions about qmail, join the qmail mailing list; see
-http://pobox.com/~djb/qmail.html.
+See http://lifewithqmail.org/lwq.html
+and EXTTODO in this archive.
Index: install-big.c
===================================================================
--- install-big.c	(.../trunk)	(Revision 1)
+++ install-big.c	(.../branches/bulkmailer)	(Revision 29)
@@ -1,12 +1,21 @@
-#include "auto_qmail.h"
 #include "auto_split.h"
 #include "auto_uids.h"
 #include "fmt.h"
 #include "fifo.h"
 
+/* Fool auto_uids.o into pulling the uid/gid files from the subdirectory
+ * "owners" in the current directory.  This requires that the command
+ * "./make-owners ." be executed in the source directory before running
+ * qmail-hier.  This unfortunately hoses up the standard install, and so
+ * (it will install into the current directory instead of /var/qmail),
+ * and so it requires the install-path patch for proper operation.
+ */
+char auto_qmail[] = ".";
+
 char buf[100 + FMT_ULONG];
 
-void dsplit(base,uid,mode)
+void dsplit(auto_qmail,base,uid,mode)
+char *auto_qmail;
 char *base; /* must be under 100 bytes */
 int uid;
 int mode;
@@ -27,8 +36,21 @@
   }
 }
 
-void hier()
+void hier(auto_qmail)
+char *auto_qmail;
 {
+  get_uid(auto_uida);
+  get_uid(auto_uidd);
+  get_uid(auto_uidl);
+  get_uid(auto_uido);
+  get_uid(auto_uidp);
+  get_uid(auto_uidq);
+  get_uid(auto_uidr);
+  get_uid(auto_uids);
+
+  get_gid(auto_gidq);
+  get_gid(auto_gidn);
+
   h(auto_qmail,auto_uido,auto_gidq,0755);
 
   d(auto_qmail,"control",auto_uido,auto_gidq,0755);
@@ -54,10 +76,10 @@
   d(auto_qmail,"queue/todo",auto_uidq,auto_gidq,0750);
   d(auto_qmail,"queue/bounce",auto_uids,auto_gidq,0700);
 
-  dsplit("queue/mess",auto_uidq,0750);
-  dsplit("queue/info",auto_uids,0700);
-  dsplit("queue/local",auto_uids,0700);
-  dsplit("queue/remote",auto_uids,0700);
+  dsplit(auto_qmail,"queue/mess",auto_uidq,0750);
+  dsplit(auto_qmail,"queue/info",auto_uids,0700);
+  dsplit(auto_qmail,"queue/local",auto_uids,0700);
+  dsplit(auto_qmail,"queue/remote",auto_uids,0700);
 
   d(auto_qmail,"queue/lock",auto_uidq,auto_gidq,0750);
   z(auto_qmail,"queue/lock/tcpto",1024,auto_uidr,auto_gidq,0644);
@@ -108,6 +130,9 @@
   c(auto_qmail,"bin","qmail-rspawn",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-clean",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-send",auto_uido,auto_gidq,0711);
+#ifdef EXTERNAL_TODO
+  c(auto_qmail,"bin","qmail-todo",auto_uido,auto_gidq,0711);
+#endif
   c(auto_qmail,"bin","splogger",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-newu",auto_uido,auto_gidq,0700);
   c(auto_qmail,"bin","qmail-newmrh",auto_uido,auto_gidq,0700);
Index: error.3
===================================================================
--- error.3	(.../trunk)	(Revision 1)
+++ error.3	(.../branches/bulkmailer)	(Revision 29)
@@ -3,9 +3,9 @@
 error \- syscall error codes
 .SH SYNTAX
 .B #include <error.h>
+.br
+.B #include <errno.h>
 
-extern int \fBerrno\fP;
-
 extern int \fBerror_intr\fP;
 .br
 extern int \fBerror_nomem\fP;
Index: README
===================================================================
--- README	(.../trunk)	(Revision 1)
+++ README	(.../branches/bulkmailer)	(Revision 29)
@@ -3,6 +3,31 @@
 Copyright 1998
 D. J. Bernstein, qmail@pobox.com
 
+netqmail 1.04
+20031024
+No copyright claimed for changes from qmail 1.03 to netqmail 1.04
+Russell Nelson, nelson@qmail.org
+NOTE: netqmail 1.04 is a community-assembled distribution of qmail from
+the official qmail-1.03.tar.gz and patches approved by the community.
+D. J. Bernstein did not participate in, nor has he been asked to
+approve of this distribution.
+
+netqmail 1.05
+20040121
+James Craig Burley claims copyright on the qmail-isoc patch. For
+more details, see the COPYRIGHTS file shipped with the netqmail-1.05
+distribution.
+
+James' patch has been combined with the original netqmail-1.04 patch
+and the result incorporated into a unified netqmail-1.05 patch.
+Apart from James' copyrights, no other copyright is claimed by the
+distributors of netqmail for changes from qmail 1.03 to netqmail 1.05.
+
+NOTE: netqmail 1.05 is a community-assembled distribution of qmail from
+the official qmail-1.03.tar.gz and patches approved by the community.
+D. J. Bernstein did not participate in, nor has he been asked to
+approve of this distribution.
+
 qmail is a secure, reliable, efficient, simple message transfer agent.
 It is meant as a replacement for the entire sendmail-binmail system on
 typical Internet-connected UNIX hosts. See BLURB, BLURB2, BLURB3, and
Index: FAQ
===================================================================
--- FAQ	(.../trunk)	(Revision 1)
+++ FAQ	(.../branches/bulkmailer)	(Revision 29)
@@ -1,3 +1,6 @@
+See http://cr.yp.to/qmail/faq.html for newer FAQs not included in this
+document, and http://qmail.org/ for qmail community contributions.
+
 1. Controlling the appearance of outgoing messages
 1.1. How do I set up host masquerading?
 1.2. How do I set up user masquerading?
Index: EXTTODO-INFO
===================================================================
--- EXTTODO-INFO	(.../trunk)	(Revision 0)
+++ EXTTODO-INFO	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,11 @@
+Files modified:
+Makefile
+EXTTODO
+FILES
+TARGETS
+qmail-send.c
+qmail-todo.c
+qmail-start.c
+hier.c
+install-big.c
+
Index: cdbmake_add.c
===================================================================
--- cdbmake_add.c	(.../trunk)	(Revision 1)
+++ cdbmake_add.c	(.../branches/bulkmailer)	(Revision 29)
@@ -1,3 +1,4 @@
+#include "alloc.h"
 #include "cdbmake.h"
 
 void cdbmake_init(cdbm)
Index: qmail-control.9
===================================================================
--- qmail-control.9	(.../trunk)	(Revision 1)
+++ qmail-control.9	(.../branches/bulkmailer)	(Revision 29)
@@ -40,7 +40,7 @@
 .ta 5c 10c
 control	default	used by
 
-.I badmailfrom	\fR(none)	\fRqmail-smtpd
+.I badmailfrom	\fR(none)	\fRqmail-smtpd, qmail-qmtpd
 .I bouncefrom	\fRMAILER-DAEMON	\fRqmail-send
 .I bouncehost	\fIme	\fRqmail-send
 .I concurrencylocal	\fR10	\fRqmail-send
@@ -56,6 +56,7 @@
 .I localiphost	\fIme	\fRqmail-smtpd
 .I locals	\fIme	\fRqmail-send
 .I morercpthosts	\fR(none)	\fRqmail-smtpd
+.I outgoingips	\fR0.0.0.0	\fRqmail-remote
 .I percenthack	\fR(none)	\fRqmail-send
 .I plusdomain	\fIme	\fRqmail-inject
 .I qmqpservers	\fR(none)	\fRqmail-qmqpc
Index: qmail-qmtpd.8
===================================================================
--- qmail-qmtpd.8	(.../trunk)	(Revision 1)
+++ qmail-qmtpd.8	(.../branches/bulkmailer)	(Revision 29)
@@ -19,6 +19,7 @@
 .IR rcpthosts ,
 .IR morercpthosts ,
 .BR RELAYCLIENT ,
+.IR badmailfrom ,
 .IR databytes ,
 and
 .B DATABYTES
Index: Makefile
===================================================================
--- Makefile	(.../trunk)	(Revision 1)
+++ Makefile	(.../branches/bulkmailer)	(Revision 29)
@@ -1,5 +1,7 @@
 # Don't edit Makefile! Use conf-* for configuration.
 
+DEFINES=-DEXTERNAL_TODO # use to enable external todo
+
 SHELL=/bin/sh
 
 default: it
@@ -27,15 +29,6 @@
 	echo LD=\'`head -1 conf-ld`\' \
 	) > auto-ccld.sh
 
-auto-gid: \
-load auto-gid.o substdio.a error.a str.a fs.a
-	./load auto-gid substdio.a error.a str.a fs.a 
-
-auto-gid.o: \
-compile auto-gid.c subfd.h substdio.h substdio.h readwrite.h exit.h \
-scan.h fmt.h
-	./compile auto-gid.c
-
 auto-int: \
 load auto-int.o substdio.a error.a str.a fs.a
 	./load auto-int substdio.a error.a str.a fs.a 
@@ -60,15 +53,6 @@
 compile auto-str.c substdio.h readwrite.h exit.h
 	./compile auto-str.c
 
-auto-uid: \
-load auto-uid.o substdio.a error.a str.a fs.a
-	./load auto-uid substdio.a error.a str.a fs.a 
-
-auto-uid.o: \
-compile auto-uid.c subfd.h substdio.h substdio.h readwrite.h exit.h \
-scan.h fmt.h
-	./compile auto-uid.c
-
 auto_break.c: \
 auto-str conf-break
 	./auto-str auto_break \
@@ -110,22 +94,8 @@
 compile auto_split.c
 	./compile auto_split.c
 
-auto_uids.c: \
-auto-uid auto-gid conf-users conf-groups
-	( ./auto-uid auto_uida `head -1 conf-users` \
-	&&./auto-uid auto_uidd `head -2 conf-users | tail -1` \
-	&&./auto-uid auto_uidl `head -3 conf-users | tail -1` \
-	&&./auto-uid auto_uido `head -4 conf-users | tail -1` \
-	&&./auto-uid auto_uidp `head -5 conf-users | tail -1` \
-	&&./auto-uid auto_uidq `head -6 conf-users | tail -1` \
-	&&./auto-uid auto_uidr `head -7 conf-users | tail -1` \
-	&&./auto-uid auto_uids `head -8 conf-users | tail -1` \
-	&&./auto-gid auto_gidq `head -1 conf-groups` \
-	&&./auto-gid auto_gidn `head -2 conf-groups | tail -1` \
-	) > auto_uids.c.tmp && mv auto_uids.c.tmp auto_uids.c
-
 auto_uids.o: \
-compile auto_uids.c
+compile auto_uids.c auto_uids.h
 	./compile auto_uids.c
 
 auto_usera.c: \
@@ -263,7 +233,7 @@
 	cdbmake_add.o
 
 cdbmake_add.o: \
-compile cdbmake_add.c cdbmake.h uint32.h
+compile cdbmake_add.c cdbmake.h alloc.h uint32.h
 	./compile cdbmake_add.c
 
 cdbmake_hash.o: \
@@ -702,8 +672,8 @@
 	./compile hfield.c
 
 hier.o: \
-compile hier.c auto_qmail.h auto_split.h auto_uids.h fmt.h fifo.h
-	./compile hier.c
+compile hier.c auto_split.h auto_uids.h fmt.h fifo.h
+	./compile $(DEFINES) hier.c
 
 home: \
 home.sh conf-qmail
@@ -740,22 +710,20 @@
 	./compile idedit.c
 
 install: \
-load install.o fifo.o hier.o auto_qmail.o auto_split.o auto_uids.o \
+load install.o fifo.o hier.o auto_split.o auto_uids.o \
 strerr.a substdio.a open.a error.a str.a fs.a
-	./load install fifo.o hier.o auto_qmail.o auto_split.o \
+	./load install fifo.o hier.o auto_split.o \
 	auto_uids.o strerr.a substdio.a open.a error.a str.a fs.a 
 
 install-big: \
-load install-big.o fifo.o install.o auto_qmail.o auto_split.o \
-auto_uids.o strerr.a substdio.a open.a error.a str.a fs.a
-	./load install-big fifo.o install.o auto_qmail.o \
-	auto_split.o auto_uids.o strerr.a substdio.a open.a error.a \
-	str.a fs.a 
+load install-big.o fifo.o install.o auto_split.o auto_uids.o \
+strerr.a substdio.a open.a error.a str.a fs.a
+	./load install-big fifo.o install.o auto_split.o auto_uids.o \
+	strerr.a substdio.a open.a error.a str.a fs.a 
 
 install-big.o: \
-compile install-big.c auto_qmail.h auto_split.h auto_uids.h fmt.h \
-fifo.h
-	./compile install-big.c
+compile install-big.c auto_split.h auto_uids.h fmt.h fifo.h
+	./compile $(DEFINES) install-big.c
 
 install.o: \
 compile install.c substdio.h strerr.h error.h open.h readwrite.h \
@@ -763,9 +731,9 @@
 	./compile install.c
 
 instcheck: \
-load instcheck.o fifo.o hier.o auto_qmail.o auto_split.o auto_uids.o \
+load instcheck.o fifo.o hier.o auto_split.o auto_uids.o \
 strerr.a substdio.a error.a str.a fs.a
-	./load instcheck fifo.o hier.o auto_qmail.o auto_split.o \
+	./load instcheck fifo.o hier.o auto_split.o \
 	auto_uids.o strerr.a substdio.a error.a str.a fs.a 
 
 instcheck.o: \
@@ -808,7 +776,7 @@
 forward preline condredirect bouncesaying except maildirmake \
 maildir2mbox maildirwatch qail elq pinq idedit install-big install \
 instcheck home home+df proc proc+df binm1 binm1+df binm2 binm2+df \
-binm3 binm3+df
+binm3 binm3+df make-owners qmail-todo
 
 load: \
 make-load warn-auto.sh systype
@@ -918,6 +886,15 @@
 	cat auto-ccld.sh make-makelib.sh > make-makelib
 	chmod 755 make-makelib
 
+make-owners: \
+make-owners.head conf-users conf-groups
+	cat make-owners.head >make-owners
+	for num in a d l o p q r s; do read name; \
+		echo checkuid $$num $$name; done <conf-users >>make-owners
+	for num in q n; do read name; \
+		echo checkgid $$num $$name; done <conf-groups >>make-owners
+	chmod +x make-owners
+
 makelib: \
 make-makelib warn-auto.sh systype
 	( cat warn-auto.sh; ./make-makelib "`cat systype`" ) > \
@@ -1047,7 +1024,7 @@
 	chmod 755 proc+df
 
 prot.o: \
-compile prot.c hasshsgr.h prot.h
+compile prot.c hasshsgr.h prot.h auto_uids.h
 	./compile prot.c
 
 qail: \
@@ -1201,10 +1178,9 @@
 load qmail-lspawn.o spawn.o prot.o slurpclose.o coe.o sig.a wait.a \
 case.a cdb.a fd.a open.a stralloc.a alloc.a substdio.a error.a str.a \
 fs.a auto_qmail.o auto_uids.o auto_spawn.o
-	./load qmail-lspawn spawn.o prot.o slurpclose.o coe.o \
+	./load qmail-lspawn spawn.o prot.o slurpclose.o coe.o auto_uids.o \
 	sig.a wait.a case.a cdb.a fd.a open.a stralloc.a alloc.a \
-	substdio.a error.a str.a fs.a auto_qmail.o auto_uids.o \
-	auto_spawn.o 
+	substdio.a error.a str.a fs.a auto_qmail.o auto_spawn.o 
 
 qmail-lspawn.0: \
 qmail-lspawn.8
@@ -1367,14 +1343,15 @@
 	./compile qmail-qmqpd.c
 
 qmail-qmtpd: \
-load qmail-qmtpd.o rcpthosts.o control.o constmap.o received.o \
+load qmail-qmtpd.o realrcptto.o rcpthosts.o control.o constmap.o received.o \
 date822fmt.o now.o qmail.o cdb.a fd.a wait.a datetime.a open.a \
 getln.a sig.a case.a env.a stralloc.a alloc.a substdio.a error.a \
-str.a fs.a auto_qmail.o
-	./load qmail-qmtpd rcpthosts.o control.o constmap.o \
+str.a fs.a auto_qmail.o auto_break.o auto_usera.o
+	./load qmail-qmtpd realrcptto.o rcpthosts.o control.o constmap.o \
 	received.o date822fmt.o now.o qmail.o cdb.a fd.a wait.a \
 	datetime.a open.a getln.a sig.a case.a env.a stralloc.a \
-	alloc.a substdio.a error.a str.a fs.a auto_qmail.o 
+	alloc.a substdio.a error.a str.a fs.a auto_qmail.o auto_break.o \
+	auto_usera.o
 
 qmail-qmtpd.0: \
 qmail-qmtpd.8
@@ -1422,10 +1399,10 @@
 load qmail-queue.o triggerpull.o fmtqfn.o now.o date822fmt.o \
 datetime.a seek.a ndelay.a open.a sig.a alloc.a substdio.a error.a \
 str.a fs.a auto_qmail.o auto_split.o auto_uids.o
-	./load qmail-queue triggerpull.o fmtqfn.o now.o \
+	./load qmail-queue triggerpull.o fmtqfn.o now.o auto_uids.o \
 	date822fmt.o datetime.a seek.a ndelay.a open.a sig.a \
 	alloc.a substdio.a error.a str.a fs.a auto_qmail.o \
-	auto_split.o auto_uids.o 
+	auto_split.o
 
 qmail-queue.0: \
 qmail-queue.8
@@ -1464,10 +1441,9 @@
 load qmail-rspawn.o spawn.o tcpto_clean.o now.o coe.o sig.a open.a \
 seek.a lock.a wait.a fd.a stralloc.a alloc.a substdio.a error.a str.a \
 auto_qmail.o auto_uids.o auto_spawn.o
-	./load qmail-rspawn spawn.o tcpto_clean.o now.o coe.o \
+	./load qmail-rspawn spawn.o tcpto_clean.o now.o coe.o auto_uids.o \
 	sig.a open.a seek.a lock.a wait.a fd.a stralloc.a alloc.a \
-	substdio.a error.a str.a auto_qmail.o auto_uids.o \
-	auto_spawn.o 
+	substdio.a error.a str.a auto_qmail.o auto_spawn.o 
 
 qmail-rspawn.0: \
 qmail-rspawn.8
@@ -1483,12 +1459,12 @@
 trigger.o fmtqfn.o quote.o now.o readsubdir.o qmail.o date822fmt.o \
 datetime.a case.a ndelay.a getln.a wait.a seek.a fd.a sig.a open.a \
 lock.a stralloc.a alloc.a substdio.a error.a str.a fs.a auto_qmail.o \
-auto_split.o
+auto_split.o env.a
 	./load qmail-send qsutil.o control.o constmap.o newfield.o \
 	prioq.o trigger.o fmtqfn.o quote.o now.o readsubdir.o \
 	qmail.o date822fmt.o datetime.a case.a ndelay.a getln.a \
 	wait.a seek.a fd.a sig.a open.a lock.a stralloc.a alloc.a \
-	substdio.a error.a str.a fs.a auto_qmail.o auto_split.o 
+	substdio.a error.a str.a fs.a auto_qmail.o auto_split.o env.a
 
 qmail-send.0: \
 qmail-send.8
@@ -1509,7 +1485,7 @@
 scan.h case.h auto_qmail.h trigger.h newfield.h stralloc.h quote.h \
 qmail.h substdio.h qsutil.h prioq.h datetime.h gen_alloc.h constmap.h \
 fmtqfn.h readsubdir.h direntry.h
-	./compile qmail-send.c
+	./compile $(DEFINES) qmail-send.c
 
 qmail-showctl: \
 load qmail-showctl.o auto_uids.o control.o open.a getln.a stralloc.a \
@@ -1532,17 +1508,17 @@
 	./compile qmail-showctl.c
 
 qmail-smtpd: \
-load qmail-smtpd.o rcpthosts.o commands.o timeoutread.o \
+load qmail-smtpd.o realrcptto.o rcpthosts.o commands.o timeoutread.o \
 timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o received.o \
 date822fmt.o now.o qmail.o cdb.a fd.a wait.a datetime.a getln.a \
-open.a sig.a case.a env.a stralloc.a alloc.a substdio.a error.a str.a \
-fs.a auto_qmail.o socket.lib
-	./load qmail-smtpd rcpthosts.o commands.o timeoutread.o \
+open.a sig.a case.a env.a stralloc.a alloc.a strerr.a substdio.a error.a str.a \
+fs.a auto_qmail.o auto_break.o auto_usera.o socket.lib
+	./load qmail-smtpd realrcptto.o rcpthosts.o commands.o timeoutread.o \
 	timeoutwrite.o ip.o ipme.o ipalloc.o control.o constmap.o \
 	received.o date822fmt.o now.o qmail.o cdb.a fd.a wait.a \
 	datetime.a getln.a open.a sig.a case.a env.a stralloc.a \
-	alloc.a substdio.a error.a str.a fs.a auto_qmail.o  `cat \
-	socket.lib`
+	alloc.a strerr.a substdio.a error.a str.a fs.a auto_qmail.o auto_break.o \
+	auto_usera.o `cat socket.lib`
 
 qmail-smtpd.0: \
 qmail-smtpd.8
@@ -1557,8 +1533,10 @@
 	./compile qmail-smtpd.c
 
 qmail-start: \
-load qmail-start.o prot.o fd.a auto_uids.o
-	./load qmail-start prot.o fd.a auto_uids.o 
+load qmail-start.o prot.o fd.a auto_uids.o auto_qmail.o \
+	open_read.o substdio.a error.a
+	./load qmail-start prot.o auto_uids.o fd.a \
+	auto_qmail.o open_read.o substdio.a str.a error.a
 
 qmail-start.0: \
 qmail-start.8
@@ -1574,7 +1552,7 @@
 
 qmail-start.o: \
 compile qmail-start.c fd.h prot.h exit.h fork.h auto_uids.h
-	./compile qmail-start.c
+	./compile $(DEFINES) qmail-start.c
 
 qmail-tcpok: \
 load qmail-tcpok.o open.a lock.a strerr.a substdio.a error.a str.a \
@@ -1606,6 +1584,20 @@
 fmt.h ip.h lock.h error.h exit.h datetime.h now.h datetime.h
 	./compile qmail-tcpto.c
 
+qmail-todo: \
+load qmail-todo.o control.o constmap.o trigger.o fmtqfn.o now.o \
+readsubdir.o case.a ndelay.a getln.a sig.a open.a stralloc.a alloc.a \
+substdio.a error.a str.a fs.a auto_qmail.o auto_split.o
+	./load qmail-todo control.o constmap.o trigger.o fmtqfn.o now.o \
+	readsubdir.o case.a ndelay.a getln.a sig.a open.a stralloc.a \
+	alloc.a substdio.a error.a str.a fs.a auto_qmail.o auto_split.o
+
+qmail-todo.o: \
+compile alloc.h auto_qmail.h byte.h constmap.h control.h direntry.h error.h \
+exit.h fmt.h fmtqfn.h getln.h open.h ndelay.h now.h readsubdir.h readwrite.h \
+scan.h select.h str.h stralloc.h substdio.h trigger.h
+	./compile $(DEFINES) qmail-todo.c
+
 qmail-upq: \
 warn-auto.sh qmail-upq.sh conf-qmail conf-break conf-split
 	cat warn-auto.sh qmail-upq.sh \
@@ -1686,6 +1678,11 @@
 auto_split.h
 	./compile readsubdir.c
 
+realrcptto.o: \
+compile realrcptto.c auto_break.h auto_usera.h byte.h case.h cdb.h \
+constmap.h error.h fmt.h open.h str.h stralloc.h uint32.h
+	./compile realrcptto.c
+
 received.o: \
 compile received.c fmt.h qmail.h substdio.h now.h datetime.h \
 datetime.h date822fmt.h received.h
@@ -1792,7 +1789,7 @@
 proc+df.sh binm1.sh binm2.sh binm3.sh binm1+df.sh binm2+df.sh \
 binm3+df.sh find-systype.sh make-compile.sh make-load.sh \
 make-makelib.sh trycpp.c warn-auto.sh auto-str.c auto-int.c \
-auto-int8.c auto-gid.c auto-uid.c hier.c install.c instcheck.c \
+auto-int8.c hier.c install.c instcheck.c \
 install-big.c alloc.3 alloc.h alloc.c alloc_re.c case.3 case.h \
 case_diffb.c case_diffs.c case_lowerb.c case_lowers.c case_starts.c \
 cdb.3 cdb.h cdb_hash.c cdb_seek.c cdb_unpack.c cdbmake.h \
@@ -1892,7 +1889,7 @@
 
 spawn.o: \
 compile chkspawn spawn.c sig.h wait.h substdio.h byte.h str.h \
-stralloc.h gen_alloc.h select.h exit.h coe.h open.h error.h \
+stralloc.h gen_alloc.h select.h exit.h alloc.h coe.h open.h error.h \
 auto_qmail.h auto_uids.h auto_spawn.h
 	./chkspawn
 	./compile spawn.c
Index: error.h
===================================================================
--- error.h	(.../trunk)	(Revision 1)
+++ error.h	(.../branches/bulkmailer)	(Revision 29)
@@ -1,7 +1,7 @@
 #ifndef ERROR_H
 #define ERROR_H
 
-extern int errno;
+#include <errno.h>
 
 extern int error_intr;
 extern int error_nomem;
Index: EXTTODO
===================================================================
--- EXTTODO	(.../trunk)	(Revision 0)
+++ EXTTODO	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,114 @@
+EXTTODO by Claudio Jeker <jeker@n-r-g.com> and 
+Andre Oppermann <opi@nrg4u.com>
+(c) 1998,1999,2000,2001,2002 Internet Business Solutions Ltd.
+
+The EXTTODO patch is a part of the qmail-ldap patch.
+This patches for qmail come with NO WARRANTY.
+
+These patches are under the BSD license.
+
+RELEASE: 5. Jan. 2003
+
+EXTTODO:
+======================
+
+TOC:
+ WHAT DOES IT DO
+ INSTALL
+ CONFIG FILES
+ SETUP
+ BIG PICTURE
+
+NEWS:
+ 
+ This is the first release of the EXTTODO patch.
+
+================================================================================
+
+WHAT DOES IT DO
+
+ The exttodo patch addresses a problem known as the silly qmail (queue)
+ problem. This problem is found only on system with high injection rates.
+
+ qmail with a big local and remote concurrency could deliver a tremendous 
+ amount of messages but normally this can not be achieved because qmail-send
+ becomes a bottleneck on those high volumes servers.
+ qmail-send preprocesses all new messages before distributing them for local
+ or remote delivering. In one run qmail-send does one todo run but has the 
+ ability to close multiple jobs. Because of this layout qmail-send can not 
+ feed all the new available (local/remote) delivery slots and therefor it is 
+ not possible to achieve the maximum throughput.
+ This would be a minor problem if one qmail-send run could be done in extreme
+ short time but because of many file system calls (fsync and (un)link) a todo
+ run is expensive and throttles the throughput.
+
+ The exttodo patch tries to solve the problem by moving the todo routine into 
+ an external program. This reduces the run time in qmail-send.
+
+ exttodo adds a new program to qmail called qmail-todo. qmail-todo prepares
+ incoming messages for local and remote delivering (by creating info/<messid>
+ local/<messid> and remote/<messid> and removing todo/<messid>). See also
+ INTERNALS. As next qmail-todo transmits the <messid> to qmail-send which will
+ add this message into the priority queue which schedules the message for 
+ delivery. 
+
+INSTALL
+
+ To enable the exttodo patch you need to define EXTERNAL_TODO while compiling
+ qmail(-ldap) this can be done with the -D flag of cc (e.g. cc -DEXTERNAL_TODO).
+
+ NOTE: the exttodo patch can also be used on qmail systems without the 
+ qmail-ldap patch.
+ 
+================================================================================
+
+CONFIG FILES
+
+ No additional control files are used or needed.
+
+================================================================================
+
+SETUP
+
+ qmail-todo will be started by qmail-start and therefor no additional setup
+ is needed.
+
+ To verify that exttodo is running just check if qmail-todo is running.
+
+================================================================================
+
+BIG PICTURE
+
+               +-------+   +-------+
+               | clean |   | clean |
+               +--0-1--+   +--0-1--+       +-----------+
+         trigger  ^ |         ^ |        +->0,1 lspawn |
+            |     | v         | v       /  +-----------+
+ +-------+  v  +--2-3--+   +--5-6--+   /
+ |       |  |  |       0<--7     1,2<-+
+ | queue |--+--| todo  |   | send  |
+ |       |  |  |       1-->8     3,4<-+
+ +-------+     +-------+   +---0---+   \
+                               |        \  +-----------+
+                               v         +->0,1 rspwan |
+                           +---0---+       +-----------+
+                           | logger|
+                           +-------+
+
+Communication between qmail-send and qmail-todo
+
+todo -> send:
+   D[LRB]<mesgid>\0
+          Start delivery for new message with id <messid>.
+          the character L, R or B defines the type
+          of delivery, local, remote or both respectively.
+   L<string>\0
+          Dump string to the logger without adding additional \n or similar.
+send -> todo:
+   H      Got a SIGHUP reread ~/control/locals and ~/control/virtualdomains
+   X      Quit ASAP.
+
+qmail-todo sends "\0" terminated messages whereas qmail-send just send one
+character to qmail-todo.
+
+
Index: TODO.patches
===================================================================
--- TODO.patches	(.../trunk)	(Revision 0)
+++ TODO.patches	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,5 @@
+cut bounce if original message exceeds a certain size, see also
+http://www.qmail.org/qmail-send.mimeheaders.tar.gz, which cuts the
+whole body, and
+http://www.qmail.org/www.jedi.claranet.fr/qmail-bounce.patch which
+simply cuts at a certain size in plaintext bounces.
Index: qmail-qmtpd.c
===================================================================
--- qmail-qmtpd.c	(.../trunk)	(Revision 1)
+++ qmail-qmtpd.c	(.../branches/bulkmailer)	(Revision 29)
@@ -11,10 +11,21 @@
 #include "readwrite.h"
 #include "control.h"
 #include "received.h"
+#include "constmap.h"
 
 void badproto() { _exit(100); }
 void resources() { _exit(111); }
+void die_nomem() { resources(); }
+void die_control() { resources(); }
+void die_cdb() { resources(); }
+void die_sys() { resources(); }
 
+extern void realrcptto_init();
+extern void realrcptto_start();
+extern int realrcptto();
+extern int realrcptto_deny();
+
+
 int safewrite(fd,buf,len) int fd; char *buf; int len;
 {
   int r;
@@ -57,6 +68,22 @@
   if (ch != ',') badproto();
 }
 
+int flagbarf;
+int bmfok = 0;
+stralloc bmf = {0};
+struct constmap mapbmf;
+
+int bmfcheck(buf,len) char *buf; int len;
+{
+  int j;
+  if (!bmfok) return 0;
+  if (constmap(&mapbmf,buf,len)) return 1;
+  j = byte_rchr(buf,len,'@');
+  if (j < len)
+    if (constmap(&mapbmf,buf + j,len - j)) return 1;
+  return 0;
+}
+
 unsigned int databytes = 0;
 unsigned int bytestooverflow = 0;
 struct qmail qq;
@@ -96,8 +123,16 @@
  
   if (control_init() == -1) resources();
   if (rcpthosts_init() == -1) resources();
+
+  bmfok = control_readfile(&bmf,"control/badmailfrom",0);
+  if (bmfok == -1) resources();
+  if (bmfok)
+    if (!constmap_init(&mapbmf,bmf.s,bmf.len,0)) resources();
+
   relayclient = env_get("RELAYCLIENT");
   relayclientlen = relayclient ? str_len(relayclient) : 0;
+
+  realrcptto_init();
  
   if (control_readint(&databytes,"control/databytes") == -1) resources();
   x = env_get("DATABYTES");
@@ -114,6 +149,7 @@
   if (!local) local = "unknown";
  
   for (;;) {
+    realrcptto_start();
     if (!stralloc_copys(&failure,"")) resources();
     flagsenderok = 1;
  
@@ -181,6 +217,9 @@
  
     flagbother = 0;
     qmail_from(&qq,buf);
+
+    flagbarf = bmfcheck(buf,len);
+
     if (!flagsenderok) qmail_fail(&qq);
  
     biglen = getlen();
@@ -216,7 +255,13 @@
             case -1: resources();
             case 0: failure.s[failure.len - 1] = 'D';
           }
- 
+
+        if (flagbarf) { failure.s[failure.len -1] = 'B'; }
+
+	if (!failure.s[failure.len - 1])
+          if (!realrcptto(buf))
+            failure.s[failure.len - 1] = 'D';
+
         if (!failure.s[failure.len - 1]) {
           qmail_to(&qq,buf);
           flagbother = 1;
@@ -231,6 +276,7 @@
     result = qmail_close(&qq);
     if (!flagsenderok) result = "Dunacceptable sender (#5.1.7)";
     if (databytes) if (!bytestooverflow) result = "Dsorry, that message size exceeds my databytes limit (#5.3.4)";
+    if (realrcptto_deny()) result = "Dsorry, no mailbox here by that name. (#5.1.1)";
  
     if (*result)
       len = str_len(result);
@@ -258,6 +304,9 @@
         case 'D':
           substdio_puts(&ssout,"66:Dsorry, that domain isn't in my list of allowed rcpthosts (#5.7.1),");
           break;
+        case 'B':
+          substdio_puts(&ssout,"63:Dsorry, your envelope sender is in my badmailfrom list (#5.7.1),");
+          break;
         default:
           substdio_puts(&ssout,"46:Dsorry, I can't handle that recipient (#5.1.3),");
           break;
Index: UPGRADE
===================================================================
--- UPGRADE	(.../trunk)	(Revision 1)
+++ UPGRADE	(.../branches/bulkmailer)	(Revision 29)
@@ -3,7 +3,7 @@
 much more secure and reliable than sendmail, but that's not saying much.
 
 
-Here's how to upgrade to qmail 1.03. This procedure will overwrite the
+Here's how to upgrade to netqmail 1.05. This procedure will overwrite the
 old qmail binaries. Furthermore, it may begin delivering messages from
 the queue before you have had a chance to test it.
 
@@ -17,7 +17,7 @@
 
 
 Before starting, compare conf* to your old conf*, and make any necessary
-changes. You can copy conf* from 1.02.
+changes. You can copy conf* from 1.02 or 1.03.
 
 
 How to install:
Index: qmail-clean.c
===================================================================
--- qmail-clean.c	(.../trunk)	(Revision 1)
+++ qmail-clean.c	(.../branches/bulkmailer)	(Revision 29)
@@ -73,22 +73,25 @@
    if (line.len < 7) { respond("x"); continue; }
    if (line.len > 100) { respond("x"); continue; }
    if (line.s[line.len - 1]) { respond("x"); continue; } /* impossible */
-   for (i = 5;i < line.len - 1;++i)
+   for (i = line.len - 2;i > 4;--i) {
+     if (line.s[i] == '/') break;
      if ((unsigned char) (line.s[i] - '0') > 9)
       { respond("x"); continue; }
-   if (!scan_ulong(line.s + 5,&id)) { respond("x"); continue; }
+   }
+   if (line.s[i] == '/')
+     if (!scan_ulong(line.s + i + 1,&id)) { respond("x"); continue; }
    if (byte_equal(line.s,5,"foop/"))
     {
 #define U(prefix,flag) fmtqfn(fnbuf,prefix,id,flag); \
 if (unlink(fnbuf) == -1) if (errno != error_noent) { respond("!"); continue; }
-     U("intd/",0)
+     U("intd/",1)
      U("mess/",1)
      respond("+");
     }
    else if (byte_equal(line.s,4,"todo/"))
     {
-     U("intd/",0)
-     U("todo/",0)
+     U("intd/",1)
+     U("todo/",1)
      respond("+");
     }
    else
Index: qmail-send.c
===================================================================
--- qmail-send.c	(.../trunk)	(Revision 1)
+++ qmail-send.c	(.../branches/bulkmailer)	(Revision 29)
@@ -55,6 +55,7 @@
 stralloc bouncehost = {0};
 stralloc doublebounceto = {0};
 stralloc doublebouncehost = {0};
+stralloc boundary = {0};
 
 char strnum2[FMT_ULONG];
 char strnum3[FMT_ULONG];
@@ -96,7 +97,7 @@
 }
 
 void fnmake_info(id) unsigned long id; { fn.len = fmtqfn(fn.s,"info/",id,1); }
-void fnmake_todo(id) unsigned long id; { fn.len = fmtqfn(fn.s,"todo/",id,0); }
+void fnmake_todo(id) unsigned long id; { fn.len = fmtqfn(fn.s,"todo/",id,1); }
 void fnmake_mess(id) unsigned long id; { fn.len = fmtqfn(fn.s,"mess/",id,1); }
 void fnmake_foop(id) unsigned long id; { fn.len = fmtqfn(fn.s,"foop/",id,0); }
 void fnmake_split(id) unsigned long id; { fn.len = fmtqfn(fn.s,"",id,1); }
@@ -262,6 +263,8 @@
  while (!stralloc_copys(&comm_buf[c],"")) nomem();
  ch = delnum;
  while (!stralloc_append(&comm_buf[c],&ch)) nomem();
+ ch = delnum >> 8;
+ while (!stralloc_append(&comm_buf[c],&ch)) nomem();
  fnmake_split(id);
  while (!stralloc_cats(&comm_buf[c],fn.s)) nomem();
  while (!stralloc_0(&comm_buf[c])) nomem();
@@ -702,9 +705,17 @@
    qmail_puts(&qqt,"\nTo: ");
    while (!quote2(&quoted,bouncerecip)) nomem();
    qmail_put(&qqt,quoted.s,quoted.len);
-   qmail_puts(&qqt,"\n\
-Subject: failure notice\n\
-\n\
+						/* MIME header with boundary */
+   qmail_puts(&qqt,"\nMIME-Version: 1.0\n"
+			"Content-Type: multipart/mixed; "
+			"boundary=\"");
+   if (!stralloc_copyb(&boundary,strnum2,fmt_ulong(strnum2,birth))) nomem();
+   if (!stralloc_cat(&boundary,&bouncehost)) nomem();
+   if (!stralloc_catb(&boundary,strnum2,fmt_ulong(strnum2,id))) nomem();
+   qmail_put(&qqt,boundary.s,boundary.len);
+   qmail_puts(&qqt,"\"\nSubject: failure notice\n\n--");
+   qmail_put(&qqt,boundary.s,boundary.len);	/* def type is text/plain */
+   qmail_puts(&qqt,"\n\n\
 Hi. This is the qmail-send program at ");
    qmail_put(&qqt,bouncehost.s,bouncehost.len);
    qmail_puts(&qqt,*sender.s ? ".\n\
@@ -729,7 +740,9 @@
        qmail_fail(&qqt);
     }
 
-   qmail_puts(&qqt,*sender.s ? "--- Below this line is a copy of the message.\n\n" : "--- Below this line is the original bounce.\n\n");
+   qmail_puts(&qqt,*sender.s ? "--- Enclosed is a copy of the message.\n\n--" : "--- Enclosed is the original bounce.\n\n--");
+   qmail_put(&qqt,boundary.s,boundary.len);	/* enclosure boundary */
+   qmail_puts(&qqt,"\nContent-Type: message/rfc822\n\n");
    qmail_puts(&qqt,"Return-Path: <");
    while (!quote2(&quoted,sender.s)) nomem();
    qmail_put(&qqt,quoted.s,quoted.len);
@@ -748,6 +761,10 @@
        qmail_fail(&qqt);
     }
 
+   qmail_puts(&qqt,"\n--");			/* end boundary */
+   qmail_put(&qqt,boundary.s,boundary.len);
+   qmail_puts(&qqt,"--\n");
+
    qmail_from(&qqt,bouncesender);
    qmail_to(&qqt,bouncerecip);
    if (*qmail_close(&qqt))
@@ -906,41 +923,42 @@
      dline[c].len = REPORTMAX;
      /* qmail-lspawn and qmail-rspawn are responsible for keeping it short */
      /* but from a security point of view, we don't trust rspawn */
-   if (!ch && (dline[c].len > 1))
+   if (!ch && (dline[c].len > 2))
     {
      delnum = (unsigned int) (unsigned char) dline[c].s[0];
+     delnum += (unsigned int) ((unsigned int) dline[c].s[1]) << 8;
      if ((delnum < 0) || (delnum >= concurrency[c]) || !d[c][delnum].used)
        log1("warning: internal error: delivery report out of range\n");
      else
       {
        strnum3[fmt_ulong(strnum3,d[c][delnum].delid)] = 0;
-       if (dline[c].s[1] == 'Z')
+       if (dline[c].s[2] == 'Z')
 	 if (jo[d[c][delnum].j].flagdying)
 	  {
-	   dline[c].s[1] = 'D';
+	   dline[c].s[2] = 'D';
 	   --dline[c].len;
 	   while (!stralloc_cats(&dline[c],"I'm not going to try again; this message has been in the queue too long.\n")) nomem();
 	   while (!stralloc_0(&dline[c])) nomem();
 	  }
-       switch(dline[c].s[1])
+       switch(dline[c].s[2])
 	{
 	 case 'K':
 	   log3("delivery ",strnum3,": success: ");
-	   logsafe(dline[c].s + 2);
+	   logsafe(dline[c].s + 3);
 	   log1("\n");
 	   markdone(c,jo[d[c][delnum].j].id,d[c][delnum].mpos);
 	   --jo[d[c][delnum].j].numtodo;
 	   break;
 	 case 'Z':
 	   log3("delivery ",strnum3,": deferral: ");
-	   logsafe(dline[c].s + 2);
+	   logsafe(dline[c].s + 3);
 	   log1("\n");
 	   break;
 	 case 'D':
 	   log3("delivery ",strnum3,": failure: ");
-	   logsafe(dline[c].s + 2);
+	   logsafe(dline[c].s + 3);
 	   log1("\n");
-	   addbounce(jo[d[c][delnum].j].id,d[c][delnum].recip.s,dline[c].s + 2);
+	   addbounce(jo[d[c][delnum].j].id,d[c][delnum].recip.s,dline[c].s + 3);
 	   markdone(c,jo[d[c][delnum].j].id,d[c][delnum].mpos);
 	   --jo[d[c][delnum].j].numtodo;
 	   break;
@@ -1215,8 +1233,10 @@
 
 /* this file is too long ---------------------------------------------- TODO */
 
+#ifndef EXTERNAL_TODO
 datetime_sec nexttodorun;
-DIR *tododir; /* if 0, have to opendir again */
+int flagtododir = 0; /* if 0, have to readsubdir_init again */
+readsubdir todosubdir;
 stralloc todoline = {0};
 char todobuf[SUBSTDIO_INSIZE];
 char todobufinfo[512];
@@ -1224,7 +1244,7 @@
 
 void todo_init()
 {
- tododir = 0;
+ flagtododir = 0;
  nexttodorun = now();
  trigger_set();
 }
@@ -1236,7 +1256,7 @@
 {
  if (flagexitasap) return;
  trigger_selprep(nfds,rfds);
- if (tododir) *wakeup = 0;
+ if (flagtododir) *wakeup = 0;
  if (*wakeup > nexttodorun) *wakeup = nexttodorun;
 }
 
@@ -1253,8 +1273,7 @@
  char ch;
  int match;
  unsigned long id;
- unsigned int len;
- direntry *d;
+ int z;
  int c;
  unsigned long uid;
  unsigned long pid;
@@ -1265,32 +1284,26 @@
 
  if (flagexitasap) return;
 
- if (!tododir)
+ if (!flagtododir)
   {
    if (!trigger_pulled(rfds))
      if (recent < nexttodorun)
        return;
    trigger_set();
-   tododir = opendir("todo");
-   if (!tododir)
-    {
-     pausedir("todo");
-     return;
-    }
+   readsubdir_init(&todosubdir, "todo", pausedir);
+   flagtododir = 1;
    nexttodorun = recent + SLEEP_TODO;
   }
 
- d = readdir(tododir);
- if (!d)
+ switch(readsubdir_next(&todosubdir, &id))
   {
-   closedir(tododir);
-   tododir = 0;
-   return;
+    case 1:
+      break;
+    case 0:
+      flagtododir = 0;
+    default:
+      return;
   }
- if (str_equal(d->d_name,".")) return;
- if (str_equal(d->d_name,"..")) return;
- len = scan_ulong(d->d_name,&id);
- if (!len || d->d_name[len]) return;
 
  fnmake_todo(id);
 
@@ -1438,7 +1451,144 @@
    if (fdchan[c] != -1) close(fdchan[c]);
 }
 
+#endif
 
+/* this file is too long ------------------------------------- EXTERNAL TODO */
+
+#ifdef EXTERNAL_TODO
+stralloc todoline = {0};
+char todobuf[2048];
+int todofdin;
+int todofdout;
+int flagtodoalive;
+
+void tododied() { log1("alert: oh no! lost qmail-todo connection! dying...\n");
+ flagexitasap = 1; flagtodoalive = 0; }
+
+void todo_init()
+{
+  todofdout = 7;
+  todofdin = 8;
+  flagtodoalive = 1;
+  /* sync with external todo */
+  if (write(todofdout, "S", 1) != 1) tododied();
+  
+  return;
+}
+
+void todo_selprep(nfds,rfds,wakeup)
+int *nfds;
+fd_set *rfds;
+datetime_sec *wakeup;
+{
+  if (flagexitasap) {
+    if (flagtodoalive) {
+      write(todofdout, "X", 1);
+    }
+  }
+  if (flagtodoalive) {
+    FD_SET(todofdin,rfds);
+    if (*nfds <= todofdin)
+      *nfds = todofdin + 1;
+  }
+}
+
+void todo_del(char* s)
+{
+ int flagchan[CHANNELS];
+ struct prioq_elt pe;
+ unsigned long id;
+ unsigned int len;
+ int c;
+
+ for (c = 0;c < CHANNELS;++c) flagchan[c] = 0;
+ switch(*s++) {
+  case 'L':
+    flagchan[0] = 1;
+    break;
+  case 'R':
+    flagchan[1] = 1;
+    break;
+  case 'B':
+    flagchan[0] = 1;
+    flagchan[1] = 1;
+    break;
+  case 'X':
+    break;
+  default:
+    log1("warning: qmail-send unable to understand qmail-todo\n");
+    return;
+ }
+ 
+ len = scan_ulong(s,&id);
+ if (!len || s[len]) {
+  log1("warning: qmail-send unable to understand qmail-todo\n");
+  return;
+ }
+
+ pe.id = id; pe.dt = now();
+ for (c = 0;c < CHANNELS;++c)
+   if (flagchan[c])
+     while (!prioq_insert(&pqchan[c],&pe)) nomem();
+
+ for (c = 0;c < CHANNELS;++c) if (flagchan[c]) break;
+ if (c == CHANNELS)
+   while (!prioq_insert(&pqdone,&pe)) nomem();
+
+ return;
+}
+
+void todo_do(rfds)
+fd_set *rfds;
+{
+  int r;
+  char ch;
+  int i;
+  
+  if (!flagtodoalive) return;
+  if (!FD_ISSET(todofdin,rfds)) return;
+
+  r = read(todofdin,todobuf,sizeof(todobuf));
+  if (r == -1) return;
+  if (r == 0) {
+    if (flagexitasap)
+      flagtodoalive = 0;
+    else
+      tododied();
+    return;
+  }
+  for (i = 0;i < r;++i) {
+    ch = todobuf[i];
+    while (!stralloc_append(&todoline,&ch)) nomem();
+    if (todoline.len > REPORTMAX)
+      todoline.len = REPORTMAX;
+      /* qmail-todo is responsible for keeping it short */
+    if (!ch && (todoline.len > 1)) {
+      switch (todoline.s[0]) {
+	case 'D':
+	  if (flagexitasap) break;
+	  todo_del(todoline.s + 1);
+	  break;
+	case 'L':
+	  log1(todoline.s + 1);
+	  break;
+	case 'X':
+	  if (flagexitasap)
+	    flagtodoalive = 0;
+	  else
+	    tododied();
+	  break;
+	default:
+	  log1("warning: qmail-send unable to understand qmail-todo: report mangled\n");
+	  break;
+      }
+      todoline.len = 0;
+    }
+  }
+}
+
+#endif
+
 /* this file is too long ---------------------------------------------- MAIN */
 
 int getcontrols() { if (control_init() == -1) return 0;
@@ -1504,6 +1654,9 @@
    log1("alert: unable to reread controls: unable to switch to home directory\n");
    return;
   }
+#ifdef EXTERNAL_TODO
+ write(todofdout, "H", 1);
+#endif
  regetcontrols();
  while (chdir("queue") == -1)
   {
@@ -1544,7 +1697,7 @@
  numjobs = 0;
  for (c = 0;c < CHANNELS;++c)
   {
-   char ch;
+   char ch, ch1;
    int u;
    int r;
    do
@@ -1552,7 +1705,13 @@
    while ((r == -1) && (errno == error_intr));
    if (r < 1)
     { log1("alert: cannot start: hath the daemon spawn no fire?\n"); _exit(111); }
+   do
+     r = read(chanfdin[c],&ch1,1);
+   while ((r == -1) && (errno == error_intr));
+   if (r < 1)
+    { log1("alert: cannot start: hath the daemon spawn no fire?\n"); _exit(111); }
    u = (unsigned int) (unsigned char) ch;
+   u += (unsigned int) ((unsigned char) ch1) << 8;
    if (concurrency[c] > u) concurrency[c] = u;
    numjobs += concurrency[c];
   }
@@ -1568,8 +1727,12 @@
  todo_init();
  cleanup_init();
 
+#ifdef EXTERNAL_TODO
+ while (!flagexitasap || !del_canexit() || flagtodoalive)
+#else
  while (!flagexitasap || !del_canexit())
-  {
+#endif
+ {
    recent = now();
 
    if (flagrunasap) { flagrunasap = 0; pqrun(); }
Index: cdb_seek.c
===================================================================
--- cdb_seek.c	(.../trunk)	(Revision 1)
+++ cdb_seek.c	(.../branches/bulkmailer)	(Revision 29)
@@ -1,6 +1,5 @@
 #include <sys/types.h>
 #include <errno.h>
-extern int errno;
 #include "cdb.h"
 
 #ifndef SEEK_SET
Index: qmail-log.5
===================================================================
--- qmail-log.5	(.../trunk)	(Revision 1)
+++ qmail-log.5	(.../branches/bulkmailer)	(Revision 29)
@@ -232,6 +232,11 @@
 is unable to queue a bounce message,
 usually because the machine is almost out of memory.
 It will try again later.
+This can also be caused by incorrect settings of
+.B $QMAILQUEUE
+or errors in a program or script which
+.B $QMAILQUEUE
+points to.
 .TP
 .B unable to stat ...
 .B qmail-send
Index: qmail-qmqpc.c
===================================================================
--- qmail-qmqpc.c	(.../trunk)	(Revision 1)
+++ qmail-qmqpc.c	(.../branches/bulkmailer)	(Revision 29)
@@ -109,7 +109,7 @@
   qmqpfd = socket(AF_INET,SOCK_STREAM,0);
   if (qmqpfd == -1) die_socket();
 
-  if (timeoutconn(qmqpfd,&ip,PORT_QMQP,10) != 0) {
+  if (timeoutconn(qmqpfd,&ip,(struct ip_address *) 0,PORT_QMQP,10) != 0) {
     lasterror = 73;
     if (errno == error_timeout) lasterror = 72;
     close(qmqpfd);
Index: README.netqmail
===================================================================
--- README.netqmail	(.../trunk)	(Revision 0)
+++ README.netqmail	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,21 @@
+This is the netqmail-1.05 distribution of qmail.  It is comprised
+of qmail-1.03 plus a patch file, some documentation, and a shell
+script which prepares the files for compilation.  More information
+is available at http://qmail.org/netqmail/
+
+To collate the sources, run ./collate.sh
+It will create a netqmail-1.05 directory
+and apply the patch.  Continue the install with:
+http://www.lifewithqmail.org/lwq.html#installation
+
+Note that we couldn't get the Solaris version of patch to work.  You
+will have more happiness if you download patch from www.fsf.org.
+
+If you want to verify the md5sums of the files as patch wrote
+them here, run 'md5sum -c md5sums'.
+
+Russ Nelson <nelson@qmail.org>
+Charles Cazabon <charlesc-netqmail@discworld.dyndns.org>
+Dave Sill <de5@sws5.ornl.gov>
+Peter Samuel <Peter.Samuel@gormand.com.au>
+Henning Brauer <henning@bsws.de>
Index: remoteinfo.c
===================================================================
--- remoteinfo.c	(.../trunk)	(Revision 1)
+++ remoteinfo.c	(.../branches/bulkmailer)	(Revision 29)
@@ -44,12 +44,7 @@
   s = socket(AF_INET,SOCK_STREAM,0);
   if (s == -1) return 0;
  
-  byte_zero(&sin,sizeof(sin));
-  sin.sin_family = AF_INET;
-  byte_copy(&sin.sin_addr,4,ipl);
-  sin.sin_port = 0;
-  if (bind(s,(struct sockaddr *) &sin,sizeof(sin)) == -1) { close(s); return 0; }
-  if (timeoutconn(s,ipr,113,timeout) == -1) { close(s); return 0; }
+  if (timeoutconn(s,ipr,ipl,113,timeout) == -1) { close(s); return 0; }
   fcntl(s,F_SETFL,fcntl(s,F_GETFL,0) & ~O_NDELAY);
  
   len = 0;
Index: qmail-remote.8
===================================================================
--- qmail-remote.8	(.../trunk)	(Revision 1)
+++ qmail-remote.8	(.../branches/bulkmailer)	(Revision 29)
@@ -124,6 +124,19 @@
 .B qmail-remote
 refuses to run.
 .TP 5
+.I outgoingips
+File of IP addresses (one address per line) of which one is chosen
+to be used on outgoing connections. For efficiency and simplicity reasons
+only the first 256 addresses are evaluated. Lines beginning with
+.IR #
+and empty lines are ignored. The ip address is computed from the sender and
+the (first) recipient email address and the current unixtime/(2^21), thus the
+same outgoing ip is used for the same combination of sender and recipient
+within a period of 2^21 seconds (24.3 days). This algorithm tries to cope with
+certain grey listing techniques. The value
+.IR 0.0.0.0
+is eqivalent to the system default.
+.TP 5
 .I smtproutes
 Artificial SMTP routes.
 Each route has the form
Index: TARGETS
===================================================================
--- TARGETS	(.../trunk)	(Revision 1)
+++ TARGETS	(.../branches/bulkmailer)	(Revision 29)
@@ -150,11 +150,6 @@
 cdb_unpack.o
 cdb_seek.o
 cdb.a
-auto-uid.o
-auto-uid
-auto-gid.o
-auto-gid
-auto_uids.c
 auto_uids.o
 qmail-lspawn
 qmail-getpw.o
@@ -385,3 +380,6 @@
 man
 setup
 check
+qmail-todo.o
+qmail-todo
+make-owners
Index: instcheck.c
===================================================================
--- instcheck.c	(.../trunk)	(Revision 1)
+++ instcheck.c	(.../branches/bulkmailer)	(Revision 29)
@@ -101,8 +101,15 @@
   perm("",home,"/",file,S_IFREG,uid,gid,mode);
 }
 
-void main()
+void main(argc,argv)
+int argc;
+char **argv;
 {
-  hier();
+  char *to;
+
+  to = argv[1];
+  if (!to) strerr_die2x(100,FATAL,"instcheck: usage: instcheck dir");
+
+  hier(to);
   _exit(0);
 }
Index: qmail-qstat.sh
===================================================================
--- qmail-qstat.sh	(.../trunk)	(Revision 1)
+++ qmail-qstat.sh	(.../branches/bulkmailer)	(Revision 29)
@@ -1,7 +1,7 @@
 cd QMAIL
 messdirs=`echo queue/mess/* | wc -w`
 messfiles=`find queue/mess/* -print | wc -w`
-tododirs=`echo queue/todo | wc -w`
-todofiles=`find queue/todo -print | wc -w`
+tododirs=`echo queue/todo/* | wc -w`
+todofiles=`find queue/todo/* -print | wc -w`
 echo messages in queue: `expr $messfiles - $messdirs`
 echo messages in queue but not yet preprocessed: `expr $todofiles - $tododirs`
Index: qmail-remote.c
===================================================================
--- qmail-remote.c	(.../trunk)	(Revision 1)
+++ qmail-remote.c	(.../branches/bulkmailer)	(Revision 29)
@@ -39,6 +39,7 @@
 static stralloc sauninit = {0};
 
 stralloc helohost = {0};
+stralloc outgoingips = {0};	/* control/outgoingips */
 stralloc routes = {0};
 struct constmap maproutes;
 stralloc host = {0};
@@ -47,6 +48,7 @@
 saa reciplist = {0};
 
 struct ip_address partner;
+struct ip_address outip = {0,0,0,0};	/* use first available ip address */
 
 void out(s) char *s; { if (substdio_puts(subfdoutsmall,s) == -1) _exit(0); }
 void zero() { if (substdio_put(subfdoutsmall,"\0",1) == -1) _exit(0); }
@@ -70,6 +72,8 @@
 Unable to switch to home directory. (#4.3.0)\n"); zerodie(); }
 void temp_control() { out("Z\
 Unable to read control files. (#4.3.0)\n"); zerodie(); }
+void temp_noip() { out("Z\
+Invalid ip address in control/outgoingips (#4.3.0)\n"); zerodie(); }
 void perm_partialline() { out("D\
 SMTP cannot transfer messages with partial final lines. (#5.6.2)\n"); zerodie(); }
 void perm_usage() { out("D\
@@ -308,6 +312,35 @@
   if (!stralloc_cat(saout,&canonhost)) temp_nomem();
 }
 
+#define MAXIPRANDOM 256
+
+/* Choose one from a list of ip addresses. To cope with certain grey listing
+ * techniques, we compute this ip from the sender and the (first) recipient
+ * address, so a combination of sender and recipient gets the same ip address.
+ * To cope with blocking based on sender ip, we change the ip for a certain
+ * combination of sender and recipient after a period of 2^21 s (~ 24 days).
+ */
+int select_outip(stralloc *sa, struct ip_address *ip, stralloc *sender, stralloc *recip)
+{
+  struct ip_address ipa[MAXIPRANDOM];
+  unsigned int i, j, ipcnt;
+  unsigned long sum;
+
+  for (i = 0, j = 0, ipcnt = 0; j < sa->len && ipcnt < MAXIPRANDOM; ++j) {
+    if (!sa->s[j]) {
+      if (ip_scan(&sa->s[i], &ipa[ipcnt]) && ipme_is(&ipa[ipcnt]))
+         ++ipcnt;
+      i = j + 1;       /* set pointer to next ip address */
+    }
+  }
+  if (ipcnt == 0) return 0;
+  sum = now() >> 21;
+  for (i = 0; i < sender->len; ++i) sum += sender->s[i];
+  for (i = 0; i < recip->len; ++i) sum += recip->s[i];
+  byte_copy(ip, sizeof(struct ip_address), &ipa[sum % ipcnt]);
+  return 1;
+}
+
 void getcontrols()
 {
   if (control_init() == -1) temp_control();
@@ -318,12 +351,15 @@
     temp_control();
   switch(control_readfile(&routes,"control/smtproutes",0)) {
     case -1:
-      temp_control();
+      if (errno == error_nomem) temp_nomem(); temp_control();
     case 0:
       if (!constmap_init(&maproutes,"",0,1)) temp_nomem(); break;
     case 1:
       if (!constmap_init(&maproutes,routes.s,routes.len,1)) temp_nomem(); break;
   }
+  if (control_readfile(&outgoingips, "control/outgoingips", 0) == -1) {
+    if (errno == error_nomem) temp_nomem(); temp_control();
+  }
 }
 
 void main(argc,argv)
@@ -363,7 +399,6 @@
     if (!stralloc_copys(&host,relayhost)) temp_nomem();
   }
 
-
   addrmangle(&sender,argv[2],&flagalias,0);
  
   if (!saa_readyplus(&reciplist,0)) temp_nomem();
@@ -379,7 +414,10 @@
     ++reciplist.len;
     ++recips;
   }
-
+  /* use explicit outgoing ip only when no smtproute is defined for dest. */
+  if (!relayhost && outgoingips.s && outgoingips.len)
+    if (!select_outip(&outgoingips, &outip, &sender, reciplist.sa + 0))
+      temp_noip();
  
   random = now() + (getpid() << 16);
   switch (relayhost ? dns_ip(&ip,&host) : dns_mxip(&ip,&host,random)) {
@@ -414,7 +452,7 @@
     smtpfd = socket(AF_INET,SOCK_STREAM,0);
     if (smtpfd == -1) temp_oserr();
  
-    if (timeoutconn(smtpfd,&ip.ix[i].ip,(unsigned int) port,timeoutconnect) == 0) {
+    if (timeoutconn(smtpfd,&ip.ix[i].ip,&outip,(unsigned int) port,timeoutconnect) == 0) {
       tcpto_err(&ip.ix[i].ip,0);
       partner = ip.ix[i].ip;
       smtp(); /* does not return */
Index: auto_uids.c
===================================================================
--- auto_uids.c	(.../trunk)	(Revision 0)
+++ auto_uids.c	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,108 @@
+#include <stdlib.h>
+#include <sys/stat.h>
+#include "exit.h"
+#include "subfd.h"
+#include "substdio.h"
+#include "auto_qmail.h"
+#include "auto_uids.h"
+
+/* These are offsets from the end of either uid_files or gid_files */
+
+int auto_uida = -8;
+int auto_uidd = -7;
+int auto_uidl = -6;
+int auto_uido = -5;
+int auto_uidp = -4;
+int auto_uidq = -3;
+int auto_uidr = -2;
+int auto_uids = -1;
+
+int auto_gidn = -2;
+int auto_gidq = -1;
+
+#define uid_table_size 8
+#define gid_table_size 2
+
+struct file_ref { const char *name; int *var; };
+
+static struct file_ref uid_files[uid_table_size] = {
+	{ "uida", &auto_uida },
+	{ "uidd", &auto_uidd },
+	{ "uidl", &auto_uidl },
+	{ "uido", &auto_uido },
+	{ "uidp", &auto_uidp },
+	{ "uidq", &auto_uidq },
+	{ "uidr", &auto_uidr },
+	{ "uids", &auto_uids }
+};
+
+static struct file_ref gid_files[gid_table_size] = {
+	{ "gidn", &auto_gidn },
+	{ "gidq", &auto_gidq }
+};
+
+static int stat_control_file(name, buf) char* name; struct stat* buf;
+{
+  int result;
+  char* file = malloc(strlen(auto_qmail) + strlen(name) + 10);
+  if(file == 0)
+   {
+    substdio_putsflush(subfderr,"fatal: unable to allocate memory\n");
+    _exit(111);
+   }
+  strcpy(file, auto_qmail);
+  strcat(file, "/owners/");
+  strcat(file, name);
+  result = stat(file, buf);
+  free(file);
+  return result;
+}
+
+static int stat_uid_file(ref) struct file_ref* ref;
+{
+  struct stat statbuf;
+  if(stat_control_file(ref->name, &statbuf) == -1)
+   {
+    substdio_puts(subfderr,"fatal: unable to stat uid control file '");
+    substdio_puts(subfderr,ref->name);
+    substdio_puts(subfderr,"'\n");
+    substdio_flush(subfderr);
+    _exit(111);
+   }
+  return *(ref->var) = statbuf.st_uid;
+}
+
+static int stat_gid_file(ref) struct file_ref* ref;
+{
+  struct stat statbuf;
+  if(stat_control_file(ref->name, &statbuf) == -1)
+   {
+    substdio_puts(subfderr,"fatal: unable to stat gid control file '");
+    substdio_puts(subfderr,ref->name);
+    substdio_puts(subfderr,"'\n");
+    substdio_flush(subfderr);
+    _exit(111);
+   }
+  return *(ref->var) = statbuf.st_gid;
+}
+
+int get_uid(id) int id;
+{
+  if(id >= 0)
+    return id;
+  else if(id < -uid_table_size)
+    return -1;
+  else
+    return stat_uid_file(&uid_files[uid_table_size+id]);
+}
+
+int get_gid(id) int id;
+{
+  if(id >= 0)
+    return id;
+  else if(id < -gid_table_size)
+    return -1;
+  else
+    return stat_gid_file(&gid_files[gid_table_size+id]);
+}
+
Index: auto_uids.h
===================================================================
--- auto_uids.h	(.../trunk)	(Revision 1)
+++ auto_uids.h	(.../branches/bulkmailer)	(Revision 29)
@@ -13,4 +13,7 @@
 extern int auto_gidn;
 extern int auto_gidq;
 
+extern int get_uid();
+extern int get_gid();
+
 #endif
Index: install.c
===================================================================
--- install.c	(.../trunk)	(Revision 1)
+++ install.c	(.../branches/bulkmailer)	(Revision 29)
@@ -152,13 +152,20 @@
     strerr_die6sys(111,FATAL,"unable to chmod ",home,"/",file,": ");
 }
 
-void main()
+void main(argc,argv)
+int argc;
+char **argv;
 {
+  char *to;
+
+  to = argv[1];
+  if (!to) strerr_die2x(100,FATAL,"install: usage: install dir");
+
   fdsourcedir = open_read(".");
   if (fdsourcedir == -1)
     strerr_die2sys(111,FATAL,"unable to open current directory: ");
 
   umask(077);
-  hier();
+  hier(to);
   _exit(0);
 }
Index: make-owners.head
===================================================================
--- make-owners.head	(.../trunk)	(Revision 0)
+++ make-owners.head	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+set -e
+dir=$1
+if ! [ -d $dir ]
+then
+	echo "usage: make-owners directory"
+	exit 1
+fi
+dir=$dir/owners
+if ! [ -d $dir ]
+then
+	echo "make-owners: directory '$dir' does not exist, creating."
+	mkdir $dir
+fi
+
+checkuid() {
+  file=$dir/uid$1
+  if ! [ -e $file ]; then
+    echo "make-owners: UID file '$file' does not exist, creating."
+    touch $file
+  fi
+  chown $2 $file
+}
+
+checkgid() {
+  file=$dir/gid$1
+  if ! [ -e $file ]; then
+    echo "make-owners: GID file '$file' does not exist, creating."
+    touch $file
+  fi
+  chgrp $2 $file
+}
+
Index: COPYRIGHTS.netqmail
===================================================================
--- COPYRIGHTS.netqmail	(.../trunk)	(Revision 0)
+++ COPYRIGHTS.netqmail	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,27 @@
+netqmail-1.04
+-------------
+No copyright is claimed by the distributors of netqmail for changes from
+qmail 1.03 to netqmail 1.04.
+NOTE: netqmail 1.04 is a community-assembled distribution of qmail from
+the official qmail-1.03.tar.gz and patches approved by the community.
+D. J. Bernstein did not participate in, nor has he been asked to approve
+of this distribution.
+
+netqmail-1.05
+-------------
+James Craig Burley claims copyright on the qmail-isoc patch. See the file
+
+    old-patches/qmail-isoc.patch
+
+for details on James' copyright claim and distribution license.
+
+James' patch has been combined with the original netqmail-1.04 patch
+and the result incorporated into a unified netqmail-1.05 patch.
+
+Apart from James' copyrights, no other copyright is claimed by the
+distributors of netqmail for changes from qmail 1.03 to netqmail 1.05.
+
+NOTE: netqmail 1.05 is a community-assembled distribution of qmail from
+the official qmail-1.03.tar.gz and patches approved by the community.
+D. J. Bernstein did not participate in, nor has he been asked to approve
+of this distribution.
Index: CHANGES
===================================================================
--- CHANGES	(.../trunk)	(Revision 1)
+++ CHANGES	(.../branches/bulkmailer)	(Revision 29)
@@ -1,3 +1,24 @@
+20040121 version: netqmail 1.05
+20040121 code: qmail-smtpd is protected from exceedingly long (eg 2GB)
+         header lines
+20040121 code: qmail_lspawn, qmail-newmrh, qmail-newu, and qmail-rspawn
+         are protected from misbehaving on hosts where the size of an
+         integer is not the same as the size of a character pointer
+         (eg 64 bit hosts with 32 bit ints)
+20031027 version: netqmail 1.04.
+20031027 doc: INSTALL points to http://lifewithqmail.org/lwq.html
+20031027 doc: qmail.7 identifies installation as netqmail and points to
+         http://qmail.org/
+20031027 doc: qmail-queue.8 adds explanation of $QMAILQUEUE
+20031027 doc: qmail-log.5 adds reference to errors from $QMAILQUEUE script
+20031027 doc: FAQ also points to http://cr.yp.to/qmail/faq.html and
+         http://qmail.org/
+20031027 code: qmail-smtpd identifies itself as netqmail
+20031027 code: if $QMAILQUEUE is set, it's invoked instead of qmail-queue
+20031024 code: changed errno from int to #include.
+20031024 code: fixed .qmail parsing bug.
+20031024 code: recognize 0.0.0.0 as a local address.
+20031024 code: sendmail's -f flag now overrides environment variables.
 19980615 version: qmail 1.03.
 19980614 doc: eliminated BIN.setup in favor of a web page.
 19980614 code: added other auto* to qmail-showctl output.
Index: spawn.c
===================================================================
--- spawn.c	(.../trunk)	(Revision 1)
+++ spawn.c	(.../branches/bulkmailer)	(Revision 29)
@@ -5,6 +5,7 @@
 #include "substdio.h"
 #include "byte.h"
 #include "str.h"
+#include "alloc.h"
 #include "stralloc.h"
 #include "select.h"
 #include "exit.h"
@@ -63,7 +64,7 @@
 int flagreading = 1;
 char outbuf[1024]; substdio ssout;
 
-int stage = 0; /* reading 0:delnum 1:messid 2:sender 3:recip */
+int stage = 0; /* reading 0:delnum 1:delnum2 2:messid 3:sender 4:recip */
 int flagabort = 0; /* if 1, everything except delnum is garbage */
 int delnum;
 stralloc messid = {0};
@@ -73,6 +74,7 @@
 void err(s) char *s;
 {
  char ch; ch = delnum; substdio_put(&ssout,&ch,1);
+ ch = delnum >> 8; substdio_put(&ssout,&ch,1);
  substdio_puts(&ssout,s); substdio_putflush(&ssout,"",1);
 }
 
@@ -110,7 +112,7 @@
   { close(fdmess); err("Zqmail-spawn unable to fstat message. (#4.3.0)\n"); return; }
  if ((st.st_mode & S_IFMT) != S_IFREG)
   { close(fdmess); err("ZSorry, message has wrong type. (#4.3.5)\n"); return; }
- if (st.st_uid != auto_uidq) /* aaack! qmailq has to be trusted! */
+ if (st.st_uid != get_uid(auto_uidq)) /* aaack! qmailq has to be trusted! */
   /* your security is already toast at this point. damage control... */
   { close(fdmess); err("ZSorry, message has wrong owner. (#4.3.5)\n"); return; }
 
@@ -155,16 +157,19 @@
     {
      case 0:
        delnum = (unsigned int) (unsigned char) ch;
-       messid.len = 0; stage = 1; break;
+       stage = 1; break;
      case 1:
+       delnum += (unsigned int) ((unsigned int) ch) << 8;
+       messid.len = 0; stage = 2; break;
+     case 2:
        if (!stralloc_append(&messid,&ch)) flagabort = 1;
        if (ch) break;
-       sender.len = 0; stage = 2; break;
-     case 2:
+       sender.len = 0; stage = 3; break;
+     case 3:
        if (!stralloc_append(&sender,&ch)) flagabort = 1;
        if (ch) break;
-       recip.len = 0; stage = 3; break;
-     case 3:
+       recip.len = 0; stage = 4; break;
+     case 4:
        if (!stralloc_append(&recip,&ch)) flagabort = 1;
        if (ch) break;
        docmd();
@@ -201,7 +206,8 @@
 
  initialize(argc,argv);
 
- ch = auto_spawn; substdio_putflush(&ssout,&ch,1);
+ ch = auto_spawn; substdio_put(&ssout,&ch,1);
+ ch = auto_spawn >> 8; substdio_putflush(&ssout,&ch,1);
 
  for (i = 0;i < auto_spawn;++i) { d[i].used = 0; d[i].output.s = 0; }
 
@@ -236,7 +242,8 @@
 	   continue; /* read error on a readable pipe? be serious */
 	 if (r == 0)
 	  {
-           ch = i; substdio_put(&ssout,&ch,1);
+           char ch; ch = i; substdio_put(&ssout,&ch,1);
+           ch = i >> 8; substdio_put(&ssout,&ch,1);
 	   report(&ssout,d[i].wstat,d[i].output.s,d[i].output.len);
 	   substdio_put(&ssout,"",1);
 	   substdio_flush(&ssout);
Index: FILES
===================================================================
--- FILES	(.../trunk)	(Revision 1)
+++ FILES	(.../branches/bulkmailer)	(Revision 29)
@@ -1,3 +1,5 @@
+BIN.Makefile
+BIN.README
 BLURB
 BLURB2
 BLURB3
@@ -2,4 +4,8 @@
 BLURB4
-README
+CHANGES
+COPYRIGHTS.netqmail
+EXTTODO
+EXTTODO-INFO
 FAQ
+FILES
 INSTALL
@@ -11,18 +17,8 @@
 INSTALL.maildir
 INSTALL.mbox
 INSTALL.vsm
-REMOVE.sendmail
-REMOVE.binmail
-TEST.deliver
-TEST.receive
-UPGRADE
-THOUGHTS
-TODO
-THANKS
-CHANGES
-SECURITY
 INTERNALS
-SENDMAIL
+Makefile
 PIC.local2alias
 PIC.local2ext
 PIC.local2local
@@ -32,313 +28,341 @@
 PIC.relaybad
 PIC.relaygood
 PIC.rem2local
-FILES
-VERSION
+README
+README.netqmail
+README.patches
+REMOVE.binmail
+REMOVE.sendmail
+SECURITY
+SENDMAIL
 SYSDEPS
 TARGETS
-Makefile
-BIN.README
-BIN.Makefile
-idedit.c
-conf-break
+TEST.deliver
+TEST.receive
+THANKS
+THOUGHTS
+TODO
+TODO.patches
+UPGRADE
+VERSION
+addresses.5
+alloc.3
+alloc.c
+alloc.h
+alloc_re.c
+auto-gid.c
+auto-int.c
+auto-int8.c
+auto-str.c
+auto-uid.c
 auto_break.h
-conf-spawn
+auto_patrn.h
+auto_qmail.h
 auto_spawn.h
-chkspawn.c
-conf-split
 auto_split.h
-conf-patrn
-auto_patrn.h
-conf-users
-conf-groups
+auto_uids.c
 auto_uids.h
 auto_usera.h
-extra.h
-addresses.5
-except.1
+binm1+df.sh
+binm1.sh
+binm2+df.sh
+binm2.sh
+binm3+df.sh
+binm3.sh
 bouncesaying.1
+bouncesaying.c
+byte.h
+byte_chr.c
+byte_copy.c
+byte_cr.c
+byte_diff.c
+byte_rchr.c
+byte_zero.c
+case.3
+case.h
+case_diffb.c
+case_diffs.c
+case_lowerb.c
+case_lowers.c
+case_starts.c
+cdb.3
+cdb.h
+cdb_hash.c
+cdb_seek.c
+cdb_unpack.c
+cdbmake.h
+cdbmake_add.c
+cdbmake_hash.c
+cdbmake_pack.c
+cdbmss.c
+cdbmss.h
+chkshsgr.c
+chkspawn.c
+coe.3
+coe.c
+coe.h
+commands.c
+commands.h
 condredirect.1
+condredirect.c
+conf-break
+conf-cc
+conf-groups
+conf-ld
+conf-patrn
+conf-qmail
+conf-spawn
+conf-split
+conf-users
+config-fast.sh
+config.sh
+constmap.c
+constmap.h
+control.c
+control.h
+date822fmt.c
+date822fmt.h
+datemail.sh
+datetime.3
+datetime.c
+datetime.h
+datetime_un.c
+direntry.3
+direntry.h1
+direntry.h2
+dns.c
+dns.h
+dnscname.c
+dnsdoe.c
+dnsdoe.h
+dnsfq.c
+dnsip.c
+dnsmxip.c
+dnsptr.c
 dot-qmail.9
+elq.sh
+env.3
+env.c
+env.h
 envelopes.5
+envread.c
+error.3
+error.c
+error.h
+error_str.3
+error_str.c
+error_temp.3
+error_temp.c
+except.1
+except.c
+exit.h
+extra.h
+fd.h
+fd_copy.3
+fd_copy.c
+fd_move.3
+fd_move.c
+fifo.c
+fifo.h
+fifo_make.3
+find-systype.sh
+fmt.h
+fmt_str.c
+fmt_strn.c
+fmt_uint.c
+fmt_uint0.c
+fmt_ulong.c
+fmtqfn.c
+fmtqfn.h
 forgeries.7
+fork.h1
+fork.h2
 forward.1
+forward.c
+gen_alloc.h
+gen_allocdefs.h
+getln.3
+getln.c
+getln.h
+getln2.3
+getln2.c
+gfrom.c
+gfrom.h
+headerbody.c
+headerbody.h
+hfield.c
+hfield.h
+hier.c
+home+df.sh
+home.sh
+hostname.c
+idedit.c
+install-big.c
+install.c
+instcheck.c
+ip.c
+ip.h
+ipalloc.c
+ipalloc.h
+ipme.c
+ipme.h
+ipmeprint.c
+lock.h
+lock_ex.c
+lock_exnb.c
+lock_un.c
+maildir.5
+maildir.c
+maildir.h
 maildir2mbox.1
+maildir2mbox.c
 maildirmake.1
+maildirmake.c
 maildirwatch.1
+maildirwatch.c
 mailsubj.1
+mailsubj.sh
+make-compile.sh
+make-load.sh
+make-makelib.sh
+make-owners.head
 mbox.5
+myctime.c
+myctime.h
+ndelay.c
+ndelay.h
+ndelay_off.c
+newfield.c
+newfield.h
+now.3
+now.c
+now.h
+open.h
+open_append.c
+open_excl.c
+open_read.c
+open_trunc.c
+open_write.c
+pinq.sh
+predate.c
 preline.1
+preline.c
+prioq.c
+prioq.h
+proc+df.sh
+proc.sh
+prot.c
+prot.h
+qail.sh
 qbiff.1
+qbiff.c
+qlx.h
 qmail-clean.8
+qmail-clean.c
 qmail-command.8
 qmail-control.9
 qmail-getpw.9
+qmail-getpw.c
 qmail-header.5
 qmail-inject.8
+qmail-inject.c
 qmail-limits.9
 qmail-local.8
+qmail-local.c
 qmail-log.5
 qmail-lspawn.8
+qmail-lspawn.c
 qmail-newmrh.9
+qmail-newmrh.c
 qmail-newu.9
+qmail-newu.c
 qmail-pop3d.8
+qmail-pop3d.c
 qmail-popup.8
+qmail-popup.c
 qmail-pw2u.9
+qmail-pw2u.c
 qmail-qmqpc.8
+qmail-qmqpc.c
 qmail-qmqpd.8
+qmail-qmqpd.c
 qmail-qmtpd.8
+qmail-qmtpd.c
 qmail-qread.8
+qmail-qread.c
 qmail-qstat.8
+qmail-qstat.sh
 qmail-queue.8
+qmail-queue.c
 qmail-remote.8
+qmail-remote.c
 qmail-rspawn.8
+qmail-rspawn.c
 qmail-send.9
+qmail-send.c
 qmail-showctl.8
+qmail-showctl.c
 qmail-smtpd.8
+qmail-smtpd.c
 qmail-start.9
+qmail-start.c
 qmail-tcpok.8
+qmail-tcpok.c
 qmail-tcpto.8
+qmail-tcpto.c
+qmail-todo.c
+qmail-upq.sh
 qmail-users.9
 qmail.7
+qmail.c
+qmail.h
 qreceipt.1
-splogger.8
-tcp-env.1
-config.sh
-config-fast.sh
-qmail-clean.c
-qmail-getpw.c
-qmail-inject.c
-qmail-local.c
-qmail-lspawn.c
-qmail-newmrh.c
-qmail-newu.c
-qmail-pop3d.c
-qmail-popup.c
-qmail-pw2u.c
-qmail-qmqpc.c
-qmail-qmqpd.c
-qmail-qmtpd.c
-qmail-qread.c
-qmail-qstat.sh
-qmail-queue.c
-qmail-remote.c
-qmail-rspawn.c
-qmail-send.c
-qmail-showctl.c
-qmail-smtpd.c
-qmail-start.c
-qmail-tcpok.c
-qmail-tcpto.c
-spawn.c
-dnscname.c
-dnsfq.c
-dnsip.c
-dnsmxip.c
-dnsptr.c
-hostname.c
-ipmeprint.c
-tcp-env.c
-sendmail.c
 qreceipt.c
 qsmhook.c
-qbiff.c
-forward.c
-preline.c
-predate.c
-except.c
-bouncesaying.c
-condredirect.c
-maildirmake.c
-maildir2mbox.c
-maildirwatch.c
-splogger.c
-qail.sh
-elq.sh
-pinq.sh
-qmail-upq.sh
-datemail.sh
-mailsubj.sh
-qlx.h
+qsutil.c
+qsutil.h
+quote.c
+quote.h
+rcpthosts.c
 rcpthosts.h
-rcpthosts.c
-commands.h
-commands.c
-dnsdoe.h
-dnsdoe.c
-fmtqfn.h
-fmtqfn.c
-gfrom.h
-gfrom.c
-myctime.h
-myctime.c
-newfield.h
-newfield.c
-qsutil.h
-qsutil.c
+readsubdir.c
 readsubdir.h
-readsubdir.c
+readwrite.h
+realrcptto.c
+received.c
 received.h
-received.c
-tcpto.h
-tcpto.c
-tcpto_clean.c
-trigger.h
-trigger.c
-triggerpull.h
-triggerpull.c
-trynpbg1.c
-trysyslog.c
-conf-cc
-conf-ld
-home.sh
-home+df.sh
-proc.sh
-proc+df.sh
-binm1.sh
-binm2.sh
-binm3.sh
-binm1+df.sh
-binm2+df.sh
-binm3+df.sh
-find-systype.sh
-make-compile.sh
-make-load.sh
-make-makelib.sh
-trycpp.c
-warn-auto.sh
-auto-str.c
-auto-int.c
-auto-int8.c
-auto-gid.c
-auto-uid.c
-hier.c
-install.c
-instcheck.c
-install-big.c
-alloc.3
-alloc.h
-alloc.c
-alloc_re.c
-case.3
-case.h
-case_diffb.c
-case_diffs.c
-case_lowerb.c
-case_lowers.c
-case_starts.c
-cdb.3
-cdb.h
-cdb_hash.c
-cdb_seek.c
-cdb_unpack.c
-cdbmake.h
-cdbmake_add.c
-cdbmake_hash.c
-cdbmake_pack.c
-cdbmss.h
-cdbmss.c
-coe.3
-coe.h
-coe.c
-fd.h
-fd_copy.3
-fd_copy.c
-fd_move.3
-fd_move.c
-fifo_make.3
-fifo.h
-fifo.c
-trymkffo.c
-fork.h1
-fork.h2
-tryvfork.c
-now.3
-now.h
-now.c
-open.h
-open_append.c
-open_excl.c
-open_read.c
-open_trunc.c
-open_write.c
+remoteinfo.c
+remoteinfo.h
+scan.h
+scan_8long.c
+scan_ulong.c
 seek.h
 seek_cur.c
 seek_end.c
 seek_set.c
 seek_trunc.c
-conf-qmail
-auto_qmail.h
-qmail.h
-qmail.c
-gen_alloc.h
-gen_allocdefs.h
-stralloc.3
-stralloc.h
-stralloc_eady.c
-stralloc_pend.c
-stralloc_copy.c
-stralloc_opyb.c
-stralloc_opys.c
-stralloc_cat.c
-stralloc_catb.c
-stralloc_cats.c
-stralloc_arts.c
-strerr.h
-strerr_sys.c
-strerr_die.c
-substdio.h
-substdio.c
-substdi.c
-substdo.c
-substdio_copy.c
-subfd.h
-subfderr.c
-subfdouts.c
-subfdout.c
-subfdins.c
-subfdin.c
-readwrite.h
-exit.h
-timeoutconn.h
-timeoutconn.c
-timeoutread.h
-timeoutread.c
-timeoutwrite.h
-timeoutwrite.c
-remoteinfo.h
-remoteinfo.c
-uint32.h1
-uint32.h2
-tryulong32.c
-wait.3
-wait.h
-wait_pid.c
-wait_nohang.c
-trywaitp.c
+select.h1
+select.h2
+sendmail.c
+sgetopt.3
+sgetopt.c
+sgetopt.h
 sig.h
 sig_alarm.c
 sig_block.c
+sig_bug.c
 sig_catch.c
+sig_child.c
+sig_hup.c
+sig_misc.c
 sig_pause.c
 sig_pipe.c
-sig_child.c
 sig_term.c
-sig_hup.c
-sig_misc.c
-sig_bug.c
-trysgact.c
-trysgprm.c
-env.3
-env.h
-env.c
-envread.c
-byte.h
-byte_chr.c
-byte_copy.c
-byte_cr.c
-byte_diff.c
-byte_rchr.c
-byte_zero.c
+slurpclose.c
+slurpclose.h
+spawn.c
+splogger.8
+splogger.c
 str.h
 str_chr.c
 str_cpy.c
@@ -347,87 +371,73 @@
 str_len.c
 str_rchr.c
 str_start.c
-lock.h
-lock_ex.c
-lock_exnb.c
-lock_un.c
-tryflock.c
-getln.3
-getln.h
-getln.c
-getln2.3
-getln2.c
-sgetopt.3
-sgetopt.h
-sgetopt.c
+stralloc.3
+stralloc.h
+stralloc_arts.c
+stralloc_cat.c
+stralloc_catb.c
+stralloc_cats.c
+stralloc_copy.c
+stralloc_eady.c
+stralloc_opyb.c
+stralloc_opys.c
+stralloc_pend.c
+strerr.h
+strerr_die.c
+strerr_sys.c
+subfd.h
+subfderr.c
+subfdin.c
+subfdins.c
+subfdout.c
+subfdouts.c
 subgetopt.3
+subgetopt.c
 subgetopt.h
-subgetopt.c
-error.3
-error_str.3
-error_temp.3
-error.h
-error.c
-error_str.c
-error_temp.c
-fmt.h
-fmt_str.c
-fmt_strn.c
-fmt_uint.c
-fmt_uint0.c
-fmt_ulong.c
-scan.h
-scan_ulong.c
-scan_8long.c
-slurpclose.h
-slurpclose.c
-quote.h
-quote.c
-hfield.h
-hfield.c
-headerbody.h
-headerbody.c
+substdi.c
+substdio.c
+substdio.h
+substdio_copy.c
+substdo.c
+tcp-env.1
+tcp-env.c
+tcp-environ.5
+tcpto.c
+tcpto.h
+tcpto_clean.c
+timeoutconn.c
+timeoutconn.h
+timeoutread.c
+timeoutread.h
+timeoutwrite.c
+timeoutwrite.h
+token822.c
 token822.h
-token822.c
-control.h
-control.c
-datetime.3
-datetime.h
-datetime.c
-datetime_un.c
-prioq.h
-prioq.c
-date822fmt.h
-date822fmt.c
-dns.h
-dns.c
+trigger.c
+trigger.h
+triggerpull.c
+triggerpull.h
+trycpp.c
+trydrent.c
+tryflock.c
 trylsock.c
+trymkffo.c
+trynpbg1.c
 tryrsolv.c
-ip.h
-ip.c
-ipalloc.h
-ipalloc.c
-select.h1
-select.h2
+trysalen.c
+trysgact.c
+trysgprm.c
+tryshsgr.c
 trysysel.c
-ndelay.h
-ndelay.c
-ndelay_off.c
-direntry.3
-direntry.h1
-direntry.h2
-trydrent.c
-prot.h
-prot.c
-chkshsgr.c
+trysyslog.c
+tryulong32.c
+tryvfork.c
+trywaitp.c
+uint32.h1
+uint32.h2
+wait.3
+wait.h
+wait_nohang.c
+wait_pid.c
+warn-auto.sh
 warn-shsgr
-tryshsgr.c
-ipme.h
-ipme.c
-trysalen.c
-maildir.5
-maildir.h
-maildir.c
-tcp-environ.5
-constmap.h
-constmap.c
Index: qmail-todo.c
===================================================================
--- qmail-todo.c	(.../trunk)	(Revision 0)
+++ qmail-todo.c	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,682 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "alloc.h"
+#include "auto_qmail.h"
+#include "byte.h"
+#include "constmap.h"
+#include "control.h"
+#include "direntry.h"
+#include "error.h"
+#include "exit.h"
+#include "fmt.h"
+#include "fmtqfn.h"
+#include "getln.h"
+#include "open.h"
+#include "ndelay.h"
+#include "now.h"
+#include "readsubdir.h"
+#include "readwrite.h"
+#include "scan.h"
+#include "select.h"
+#include "str.h"
+#include "stralloc.h"
+#include "substdio.h"
+#include "trigger.h"
+
+/* critical timing feature #1: if not triggered, do not busy-loop */
+/* critical timing feature #2: if triggered, respond within fixed time */
+/* important timing feature: when triggered, respond instantly */
+#define SLEEP_TODO 1500 /* check todo/ every 25 minutes in any case */
+#define SLEEP_FUZZ 1 /* slop a bit on sleeps to avoid zeno effect */
+#define SLEEP_FOREVER 86400 /* absolute maximum time spent in select() */
+#define SLEEP_SYSFAIL 123
+
+stralloc percenthack = {0};
+struct constmap mappercenthack;
+stralloc locals = {0};
+struct constmap maplocals;
+stralloc vdoms = {0};
+struct constmap mapvdoms;
+stralloc envnoathost = {0};
+
+char strnum[FMT_ULONG];
+
+/* XXX not good, if qmail-send.c changes this has to be updated */
+#define CHANNELS 2
+char *chanaddr[CHANNELS] = { "local/", "remote/" };
+
+datetime_sec recent;
+
+void log1(char *x);
+void log3(char* x, char* y, char* z);
+
+int flagstopasap = 0;
+void sigterm(void)
+{
+  if (flagstopasap == 0)
+    log1("status: qmail-todo stop processing asap\n");
+  flagstopasap = 1;
+}
+
+int flagreadasap = 0; void sighup(void) { flagreadasap = 1; }
+int flagsendalive = 1; void senddied(void) { flagsendalive = 0; }
+
+void nomem() { log1("alert: out of memory, sleeping...\n"); sleep(10); }
+void pausedir(dir) char *dir;
+{ log3("alert: unable to opendir ",dir,", sleeping...\n"); sleep(10); }
+
+void cleandied()
+{ 
+  log1("alert: qmail-todo: oh no! lost qmail-clean connection! dying...\n");
+  flagstopasap = 1;
+}
+
+
+/* this file is not so long ------------------------------------- FILENAMES */
+
+stralloc fn = {0};
+
+void fnmake_init(void)
+{
+ while (!stralloc_ready(&fn,FMTQFN)) nomem();
+}
+
+void fnmake_info(unsigned long id) { fn.len = fmtqfn(fn.s,"info/",id,1); }
+void fnmake_todo(unsigned long id) { fn.len = fmtqfn(fn.s,"todo/",id,1); }
+void fnmake_mess(unsigned long id) { fn.len = fmtqfn(fn.s,"mess/",id,1); }
+void fnmake_chanaddr(unsigned long id, int c)
+{ fn.len = fmtqfn(fn.s,chanaddr[c],id,1); }
+
+
+/* this file is not so long ------------------------------------- REWRITING */
+
+stralloc rwline = {0};
+
+/* 1 if by land, 2 if by sea, 0 if out of memory. not allowed to barf. */
+/* may trash recip. must set up rwline, between a T and a \0. */
+int rewrite(char *recip)
+{
+  int i;
+  int j;
+  char *x;
+  static stralloc addr = {0};
+  int at;
+
+  if (!stralloc_copys(&rwline,"T")) return 0;
+  if (!stralloc_copys(&addr,recip)) return 0;
+
+  i = byte_rchr(addr.s,addr.len,'@');
+  if (i == addr.len) {
+    if (!stralloc_cats(&addr,"@")) return 0;
+    if (!stralloc_cat(&addr,&envnoathost)) return 0;
+  }
+
+  while (constmap(&mappercenthack,addr.s + i + 1,addr.len - i - 1)) {
+    j = byte_rchr(addr.s,i,'%');
+    if (j == i) break;
+    addr.len = i;
+    i = j;
+    addr.s[i] = '@';
+  }
+
+  at = byte_rchr(addr.s,addr.len,'@');
+
+  if (constmap(&maplocals,addr.s + at + 1,addr.len - at - 1)) {
+    if (!stralloc_cat(&rwline,&addr)) return 0;
+    if (!stralloc_0(&rwline)) return 0;
+    return 1;
+  }
+
+  for (i = 0;i <= addr.len;++i)
+    if (!i || (i == at + 1) || (i == addr.len) || ((i > at) && (addr.s[i] == '.')))
+      if (x = constmap(&mapvdoms,addr.s + i,addr.len - i)) {
+        if (!*x) break;
+        if (!stralloc_cats(&rwline,x)) return 0;
+        if (!stralloc_cats(&rwline,"-")) return 0;
+        if (!stralloc_cat(&rwline,&addr)) return 0;
+        if (!stralloc_0(&rwline)) return 0;
+        return 1;
+      }
+ 
+  if (!stralloc_cat(&rwline,&addr)) return 0;
+  if (!stralloc_0(&rwline)) return 0;
+  return 2;
+}
+
+/* this file is not so long --------------------------------- COMMUNICATION */
+
+substdio sstoqc; char sstoqcbuf[1024];
+substdio ssfromqc; char ssfromqcbuf[1024];
+stralloc comm_buf = {0};
+int comm_pos;
+int fdout = -1;
+int fdin = -1;
+
+void comm_init(void)
+{
+ substdio_fdbuf(&sstoqc,write,2,sstoqcbuf,sizeof(sstoqcbuf));
+ substdio_fdbuf(&ssfromqc,read,3,ssfromqcbuf,sizeof(ssfromqcbuf));
+
+ fdout = 1; /* stdout */
+ fdin = 0;  /* stdin */
+ if (ndelay_on(fdout) == -1)
+ /* this is so stupid: NDELAY semantics should be default on write */
+   senddied(); /* drastic, but better than risking deadlock */
+
+ while (!stralloc_ready(&comm_buf,1024)) nomem();
+}
+
+int comm_canwrite(void)
+{
+ /* XXX: could allow a bigger buffer; say 10 recipients */
+ /* XXX: returns true if there is something in the buffer */
+ if (!flagsendalive) return 0;
+ if (comm_buf.s && comm_buf.len) return 1;
+ return 0;
+}
+
+void log1(char* x)
+{
+  int pos;
+  
+  pos = comm_buf.len;
+  if (!stralloc_cats(&comm_buf,"L")) goto fail;
+  if (!stralloc_cats(&comm_buf,x)) goto fail;
+  if (!stralloc_0(&comm_buf)) goto fail;
+  return;
+  
+fail:
+  /* either all or nothing */
+  comm_buf.len = pos;
+}
+
+void log3(char* x, char *y, char *z)
+{
+  int pos;
+  
+  pos = comm_buf.len;
+  if (!stralloc_cats(&comm_buf,"L")) goto fail;
+  if (!stralloc_cats(&comm_buf,x)) goto fail;
+  if (!stralloc_cats(&comm_buf,y)) goto fail;
+  if (!stralloc_cats(&comm_buf,z)) goto fail;
+  if (!stralloc_0(&comm_buf)) goto fail;
+  return;
+  
+fail:
+  /* either all or nothing */
+  comm_buf.len = pos;
+}
+
+void comm_write(unsigned long id, int local, int remote)
+{
+  int pos;
+  char *s;
+  
+  if(local && remote) s="B";
+  else if(local) s="L";
+  else if(remote) s="R";
+  else s="X";
+  
+  pos = comm_buf.len;
+  strnum[fmt_ulong(strnum,id)] = 0;
+  if (!stralloc_cats(&comm_buf,"D")) goto fail;
+  if (!stralloc_cats(&comm_buf,s)) goto fail;
+  if (!stralloc_cats(&comm_buf,strnum)) goto fail;
+  if (!stralloc_0(&comm_buf)) goto fail;
+  return;
+  
+fail:
+  /* either all or nothing */
+  comm_buf.len = pos;
+}
+
+static int issafe(char ch)
+{
+ if (ch == '%') return 0; /* general principle: allman's code is crap */
+ if (ch < 33) return 0;
+ if (ch > 126) return 0;
+ return 1;
+}
+
+void comm_info(unsigned long id, unsigned long size, char* from, unsigned long pid, unsigned long uid)
+{
+  int pos;
+  int i;
+  
+  pos = comm_buf.len;
+  if (!stralloc_cats(&comm_buf,"Linfo msg ")) goto fail;
+  strnum[fmt_ulong(strnum,id)] = 0;
+  if (!stralloc_cats(&comm_buf,strnum)) goto fail;
+  if (!stralloc_cats(&comm_buf,": bytes ")) goto fail;
+  strnum[fmt_ulong(strnum,size)] = 0;
+  if (!stralloc_cats(&comm_buf,strnum)) goto fail;
+  if (!stralloc_cats(&comm_buf," from <")) goto fail;
+  i = comm_buf.len;
+  if (!stralloc_cats(&comm_buf,from)) goto fail;
+  for (;i < comm_buf.len;++i)
+    if (comm_buf.s[i] == '\n')
+      comm_buf.s[i] = '/';
+    else
+      if (!issafe(comm_buf.s[i]))
+	comm_buf.s[i] = '_';
+  if (!stralloc_cats(&comm_buf,"> qp ")) goto fail;
+  strnum[fmt_ulong(strnum,pid)] = 0;
+  if (!stralloc_cats(&comm_buf,strnum)) goto fail;
+  if (!stralloc_cats(&comm_buf," uid ")) goto fail;
+  strnum[fmt_ulong(strnum,uid)] = 0;
+  if (!stralloc_cats(&comm_buf,strnum)) goto fail;
+  if (!stralloc_cats(&comm_buf,"\n")) goto fail;
+  if (!stralloc_0(&comm_buf)) goto fail;
+  return;
+  
+fail:
+  /* either all or nothing */
+  comm_buf.len = pos;
+}
+
+void comm_exit(void)
+{
+  int w;
+  
+  /* if it fails exit, we have already stoped */
+  if (!stralloc_cats(&comm_buf,"X")) _exit(1);
+  if (!stralloc_0(&comm_buf)) _exit(1);
+}
+
+void comm_selprep(int *nfds, fd_set *wfds, fd_set *rfds)
+{
+  if (flagsendalive) {
+    if (flagstopasap && comm_canwrite() == 0)
+      comm_exit();
+    if (comm_canwrite()) {
+      FD_SET(fdout,wfds);
+      if (*nfds <= fdout)
+	*nfds = fdout + 1;
+    }
+    FD_SET(fdin,rfds);
+    if (*nfds <= fdin)
+      *nfds = fdin + 1;
+  }
+}
+
+void comm_do(fd_set *wfds, fd_set *rfds)
+{
+  /* first write then read */
+  if (flagsendalive)
+    if (comm_canwrite())
+      if (FD_ISSET(fdout,wfds)) {
+	int w;
+	int len;
+	len = comm_buf.len;
+	w = write(fdout,comm_buf.s + comm_pos,len - comm_pos);
+	if (w <= 0) {
+	  if ((w == -1) && (errno == error_pipe))
+	    senddied();
+	} else {
+	  comm_pos += w;
+	  if (comm_pos == len) {
+	    comm_buf.len = 0;
+	    comm_pos = 0;
+	  }
+	}
+      }
+  if (flagsendalive)
+    if (FD_ISSET(fdin,rfds)) {
+      /* there are only two messages 'H' and 'X' */
+      char c;
+      int r;
+      r = read(fdin, &c, 1);
+      if (r <= 0) {
+	if ((r == -1) && (errno != error_intr))
+	  senddied();
+      } else {
+	switch(c) {
+	  case 'H':
+	    sighup();
+	    break;
+	  case 'X':
+	    sigterm();
+	    break;
+	  default:
+	    log1("warning: qmail-todo: qmail-send speaks an obscure dialect\n");
+	    break;
+	}
+      }
+    }
+}
+
+/* this file is not so long ------------------------------------------ TODO */
+
+datetime_sec nexttodorun;
+int flagtododir = 0; /* if 0, have to readsubdir_init again */
+readsubdir todosubdir;
+stralloc todoline = {0};
+char todobuf[SUBSTDIO_INSIZE];
+char todobufinfo[512];
+char todobufchan[CHANNELS][1024];
+
+void todo_init(void)
+{
+ flagtododir = 0;
+ nexttodorun = now();
+ trigger_set();
+}
+
+void todo_selprep(int *nfds, fd_set *rfds, datetime_sec *wakeup)
+{
+ if (flagstopasap) return;
+ trigger_selprep(nfds,rfds);
+ if (flagtododir) *wakeup = 0;
+ if (*wakeup > nexttodorun) *wakeup = nexttodorun;
+}
+
+void todo_do(fd_set *rfds)
+{
+ struct stat st;
+ substdio ss; int fd;
+ substdio ssinfo; int fdinfo;
+ substdio sschan[CHANNELS];
+ int fdchan[CHANNELS];
+ int flagchan[CHANNELS];
+ char ch;
+ int match;
+ unsigned long id;
+ int z;
+ int c;
+ unsigned long uid;
+ unsigned long pid;
+
+ fd = -1;
+ fdinfo = -1;
+ for (c = 0;c < CHANNELS;++c) fdchan[c] = -1;
+
+ if (flagstopasap) return;
+
+ if (!flagtododir)
+  {
+   if (!trigger_pulled(rfds))
+     if (recent < nexttodorun)
+       return;
+   trigger_set();
+   readsubdir_init(&todosubdir, "todo", pausedir);
+   flagtododir = 1;
+   nexttodorun = recent + SLEEP_TODO;
+  }
+
+ switch(readsubdir_next(&todosubdir, &id))
+  {
+    case 1:
+      break;
+    case 0:
+      flagtododir = 0;
+    default:
+      return;
+  }
+
+ fnmake_todo(id);
+
+ fd = open_read(fn.s);
+ if (fd == -1) { log3("warning: qmail-todo: unable to open ",fn.s,"\n"); return; }
+
+ fnmake_mess(id);
+ /* just for the statistics */
+ if (stat(fn.s,&st) == -1)
+  { log3("warning: qmail-todo: unable to stat ",fn.s,"\n"); goto fail; }
+
+ for (c = 0;c < CHANNELS;++c)
+  {
+   fnmake_chanaddr(id,c);
+   if (unlink(fn.s) == -1) if (errno != error_noent)
+    { log3("warning: qmail-todo: unable to unlink ",fn.s,"\n"); goto fail; }
+  }
+
+ fnmake_info(id);
+ if (unlink(fn.s) == -1) if (errno != error_noent)
+  { log3("warning: qmail-todo: unable to unlink ",fn.s,"\n"); goto fail; }
+
+ fdinfo = open_excl(fn.s);
+ if (fdinfo == -1)
+  { log3("warning: qmail-todo: unable to create ",fn.s,"\n"); goto fail; }
+
+ strnum[fmt_ulong(strnum,id)] = 0;
+ log3("new msg ",strnum,"\n");
+
+ for (c = 0;c < CHANNELS;++c) flagchan[c] = 0;
+
+ substdio_fdbuf(&ss,read,fd,todobuf,sizeof(todobuf));
+ substdio_fdbuf(&ssinfo,write,fdinfo,todobufinfo,sizeof(todobufinfo));
+
+ uid = 0;
+ pid = 0;
+
+ for (;;)
+  {
+   if (getln(&ss,&todoline,&match,'\0') == -1)
+    {
+     /* perhaps we're out of memory, perhaps an I/O error */
+     fnmake_todo(id);
+     log3("warning: qmail-todo: trouble reading ",fn.s,"\n"); goto fail;
+    }
+   if (!match) break;
+
+   switch(todoline.s[0])
+    {
+     case 'u':
+       scan_ulong(todoline.s + 1,&uid);
+       break;
+     case 'p':
+       scan_ulong(todoline.s + 1,&pid);
+       break;
+     case 'F':
+       if (substdio_putflush(&ssinfo,todoline.s,todoline.len) == -1)
+	{
+	 fnmake_info(id);
+         log3("warning: qmail-todo: trouble writing to ",fn.s,"\n"); goto fail;
+	}
+	comm_info(id, (unsigned long) st.st_size, todoline.s + 1, pid, uid);
+       break;
+     case 'T':
+       switch(rewrite(todoline.s + 1))
+	{
+	 case 0: nomem(); goto fail;
+	 case 2: c = 1; break;
+	 default: c = 0; break;
+        }
+       if (fdchan[c] == -1)
+	{
+	 fnmake_chanaddr(id,c);
+	 fdchan[c] = open_excl(fn.s);
+	 if (fdchan[c] == -1)
+          { log3("warning: qmail-todo: unable to create ",fn.s,"\n"); goto fail; }
+	 substdio_fdbuf(&sschan[c]
+	   ,write,fdchan[c],todobufchan[c],sizeof(todobufchan[c]));
+	 flagchan[c] = 1;
+	}
+       if (substdio_bput(&sschan[c],rwline.s,rwline.len) == -1)
+        {
+	 fnmake_chanaddr(id,c);
+         log3("warning: qmail-todo: trouble writing to ",fn.s,"\n"); goto fail;
+        }
+       break;
+     default:
+       fnmake_todo(id);
+       log3("warning: qmail-todo: unknown record type in ",fn.s,"\n"); goto fail;
+    }
+  }
+
+ close(fd); fd = -1;
+
+ fnmake_info(id);
+ if (substdio_flush(&ssinfo) == -1)
+  { log3("warning: qmail-todo: trouble writing to ",fn.s,"\n"); goto fail; }
+ if (fsync(fdinfo) == -1)
+  { log3("warning: qmail-todo: trouble fsyncing ",fn.s,"\n"); goto fail; }
+ close(fdinfo); fdinfo = -1;
+
+ for (c = 0;c < CHANNELS;++c)
+   if (fdchan[c] != -1)
+    {
+     fnmake_chanaddr(id,c);
+     if (substdio_flush(&sschan[c]) == -1)
+      { log3("warning: qmail-todo: trouble writing to ",fn.s,"\n"); goto fail; }
+     if (fsync(fdchan[c]) == -1)
+      { log3("warning: qmail-todo: trouble fsyncing ",fn.s,"\n"); goto fail; }
+     close(fdchan[c]); fdchan[c] = -1;
+    }
+
+ fnmake_todo(id);
+ if (substdio_putflush(&sstoqc,fn.s,fn.len) == -1) { cleandied(); return; }
+ if (substdio_get(&ssfromqc,&ch,1) != 1) { cleandied(); return; }
+ if (ch != '+')
+  {
+   log3("warning: qmail-clean unable to clean up ",fn.s,"\n");
+   return;
+  }
+
+ comm_write(id, flagchan[0], flagchan[1]);
+ 
+ return;
+ 
+ fail:
+ if (fd != -1) close(fd);
+ if (fdinfo != -1) close(fdinfo);
+ for (c = 0;c < CHANNELS;++c)
+   if (fdchan[c] != -1) close(fdchan[c]);
+}
+
+/* this file is too long ---------------------------------------------- MAIN */
+
+int getcontrols(void)
+{
+ if (control_init() == -1) return 0;
+ if (control_rldef(&envnoathost,"control/envnoathost",1,"envnoathost") != 1) return 0;
+ if (control_readfile(&locals,"control/locals",1) != 1) return 0;
+ if (!constmap_init(&maplocals,locals.s,locals.len,0)) return 0;
+ switch(control_readfile(&percenthack,"control/percenthack",0))
+  {
+   case -1: return 0;
+   case 0: if (!constmap_init(&mappercenthack,"",0,0)) return 0; break;
+   case 1: if (!constmap_init(&mappercenthack,percenthack.s,percenthack.len,0)) return 0; break;
+  }
+ switch(control_readfile(&vdoms,"control/virtualdomains",0))
+  {
+   case -1: return 0;
+   case 0: if (!constmap_init(&mapvdoms,"",0,1)) return 0; break;
+   case 1: if (!constmap_init(&mapvdoms,vdoms.s,vdoms.len,1)) return 0; break;
+  }
+ return 1;
+}
+
+stralloc newlocals = {0};
+stralloc newvdoms = {0};
+
+void regetcontrols(void)
+{
+ int r;
+
+ if (control_readfile(&newlocals,"control/locals",1) != 1)
+  { log1("alert: qmail-todo: unable to reread control/locals\n"); return; }
+ r = control_readfile(&newvdoms,"control/virtualdomains",0);
+ if (r == -1)
+  { log1("alert: qmail-todo: unable to reread control/virtualdomains\n"); return; }
+
+ constmap_free(&maplocals);
+ constmap_free(&mapvdoms);
+
+ while (!stralloc_copy(&locals,&newlocals)) nomem();
+ while (!constmap_init(&maplocals,locals.s,locals.len,0)) nomem();
+
+ if (r)
+  {
+   while (!stralloc_copy(&vdoms,&newvdoms)) nomem();
+   while (!constmap_init(&mapvdoms,vdoms.s,vdoms.len,1)) nomem();
+  }
+ else
+   while (!constmap_init(&mapvdoms,"",0,1)) nomem();
+}
+
+void reread(void)
+{
+ if (chdir(auto_qmail) == -1)
+  {
+   log1("alert: qmail-todo: unable to reread controls: unable to switch to home directory\n");
+   return;
+  }
+ regetcontrols();
+ while (chdir("queue") == -1)
+  {
+   log1("alert: qmail-todo: unable to switch back to queue directory; HELP! sleeping...\n");
+   sleep(10);
+  }
+}
+
+void main()
+{
+ datetime_sec wakeup;
+ fd_set rfds;
+ fd_set wfds;
+ int nfds;
+ struct timeval tv;
+ int r;
+ char c;
+
+ if (chdir(auto_qmail) == -1)
+  { log1("alert: qmail-todo: cannot start: unable to switch to home directory\n"); _exit(111); }
+ if (!getcontrols())
+  { log1("alert: qmail-todo: cannot start: unable to read controls\n"); _exit(111); }
+ if (chdir("queue") == -1)
+  { log1("alert: qmail-todo: cannot start: unable to switch to queue directory\n"); _exit(111); }
+ sig_pipeignore();
+ umask(077);
+
+ fnmake_init();
+
+ todo_init();
+ comm_init();
+ 
+ do {
+   r = read(fdin, &c, 1);
+   if ((r == -1) && (errno != error_intr))
+     _exit(100); /* read failed probably qmail-send died */
+ } while (r =! 1); /* we assume it is a 'S' */
+ 
+ for (;;)
+  {
+   recent = now();
+
+   if (flagreadasap) { flagreadasap = 0; reread(); }
+   if (!flagsendalive) {
+     /* qmail-send finaly exited, so do the same. */
+     if (flagstopasap) _exit(0);
+     /* qmail-send died. We can not log and we can not work therefor _exit(1). */
+     _exit(1);
+   }
+
+   wakeup = recent + SLEEP_FOREVER;
+   FD_ZERO(&rfds);
+   FD_ZERO(&wfds);
+   nfds = 1;
+
+   todo_selprep(&nfds,&rfds,&wakeup);
+   comm_selprep(&nfds,&wfds,&rfds);
+
+   if (wakeup <= recent) tv.tv_sec = 0;
+   else tv.tv_sec = wakeup - recent + SLEEP_FUZZ;
+   tv.tv_usec = 0;
+
+   if (select(nfds,&rfds,&wfds,(fd_set *) 0,&tv) == -1)
+     if (errno == error_intr)
+       ;
+     else
+       log1("warning: qmail-todo: trouble in select\n");
+   else
+    {
+     recent = now();
+
+     todo_do(&rfds);
+     comm_do(&wfds, &rfds);
+    }
+  }
+  /* NOTREACHED */
+}
+
Index: chkspawn.c
===================================================================
--- chkspawn.c	(.../trunk)	(Revision 1)
+++ chkspawn.c	(.../branches/bulkmailer)	(Revision 29)
@@ -22,8 +22,8 @@
     _exit(1);
   }
 
-  if (auto_spawn > 255) {
-    substdio_puts(subfderr,"Oops. You have set conf-spawn higher than 255.\n");
+  if (auto_spawn > 65000) {
+    substdio_puts(subfderr,"Oops. You have set conf-spawn higher than 65000.\n");
     substdio_flush(subfderr);
     _exit(1);
   }
Index: qmail-showctl.c
===================================================================
--- qmail-showctl.c	(.../trunk)	(Revision 1)
+++ qmail-showctl.c	(.../branches/bulkmailer)	(Revision 29)
@@ -164,27 +164,27 @@
   substdio_puts(subfdout,".\n");
 
   substdio_puts(subfdout,"user ids: ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uida));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uida)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uidd));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uidd)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uidl));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uidl)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uido));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uido)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uidp));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uidp)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uidq));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uidq)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uidr));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uidr)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_uids));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_uid(auto_uids)));
   substdio_puts(subfdout,".\n");
 
   substdio_puts(subfdout,"group ids: ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_gidn));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_gid(auto_gidn)));
   substdio_puts(subfdout,", ");
-  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) auto_gidq));
+  substdio_put(subfdout,num,fmt_ulong(num,(unsigned long) get_gid(auto_gidq)));
   substdio_puts(subfdout,".\n");
 
   if (chdir(auto_qmail) == -1) {
@@ -230,6 +230,7 @@
   do_str("localiphost",1,"localiphost","Local IP address becomes ");
   do_lst("locals","Messages for me are delivered locally.","Messages for "," are delivered locally.");
   do_str("me",0,"undefined! Uh-oh","My name is ");
+  do_lst("outgoingips","None defined (use default ip).","Randomly bind to ip address "," for send connections.");
   do_lst("percenthack","The percent hack is not allowed.","The percent hack is allowed for user%host@",".");
   do_str("plusdomain",1,"plusdomain","Plus domain name is ");
   do_lst("qmqpservers","No QMQP servers.","QMQP server: ",".");
@@ -283,6 +284,7 @@
     if (str_equal(d->d_name,"localiphost")) continue;
     if (str_equal(d->d_name,"locals")) continue;
     if (str_equal(d->d_name,"me")) continue;
+    if (str_equal(d->d_name,"outgoingips")) continue;
     if (str_equal(d->d_name,"morercpthosts")) continue;
     if (str_equal(d->d_name,"morercpthosts.cdb")) continue;
     if (str_equal(d->d_name,"percenthack")) continue;
Index: dns.c
===================================================================
--- dns.c	(.../trunk)	(Revision 1)
+++ dns.c	(.../branches/bulkmailer)	(Revision 29)
@@ -7,8 +7,6 @@
 #include <errno.h>
 extern int res_query();
 extern int res_search();
-extern int errno;
-extern int h_errno;
 #include "ip.h"
 #include "ipalloc.h"
 #include "fmt.h"
Index: prot.c
===================================================================
--- prot.c	(.../trunk)	(Revision 1)
+++ prot.c	(.../branches/bulkmailer)	(Revision 29)
@@ -1,10 +1,12 @@
 #include "hasshsgr.h"
 #include "prot.h"
+#include "auto_uids.h"
 
 /* XXX: there are more portability problems here waiting to leap out at me */
 
 int prot_gid(gid) int gid;
 {
+  gid = get_gid(gid);
 #ifdef HASSHORTSETGROUPS
   short x[2];
   x[0] = gid; x[1] = 73; /* catch errors */
@@ -17,5 +19,6 @@
 
 int prot_uid(uid) int uid;
 {
+  uid = get_uid(uid);
   return setuid(uid);
 }
Index: ipme.c
===================================================================
--- ipme.c	(.../trunk)	(Revision 1)
+++ ipme.c	(.../branches/bulkmailer)	(Revision 29)
@@ -46,6 +46,11 @@
   ipme.len = 0;
   ix.pref = 0;
  
+  /* 0.0.0.0 is a special address which always refers to 
+   * "this host, this network", according to RFC 1122, Sec. 3.2.1.3a.
+  */
+  byte_copy(&ix.ip,4,"\0\0\0\0");
+  if (!ipalloc_append(&ipme,&ix)) { return 0; }
   if ((s = socket(AF_INET,SOCK_STREAM,0)) == -1) return -1;
  
   len = 256;
Index: timeoutconn.c
===================================================================
--- timeoutconn.c	(.../trunk)	(Revision 1)
+++ timeoutconn.c	(.../branches/bulkmailer)	(Revision 29)
@@ -10,11 +10,8 @@
 #include "byte.h"
 #include "timeoutconn.h"
 
-int timeoutconn(s,ip,port,timeout)
-int s;
-struct ip_address *ip;
-unsigned int port;
-int timeout;
+int timeoutconn(int s, struct ip_address *ip, struct ip_address *outip,
+		unsigned int port, int timeout)
 {
   char ch;
   struct sockaddr_in sin;
@@ -22,6 +19,15 @@
   fd_set wfds;
   struct timeval tv;
  
+  if ((outip != 0) &&
+      (outip->d[0]) && (outip->d[1]) && (outip->d[2]) && (outip->d[3])) {
+    byte_zero(&sin, sizeof(sin));
+    byte_copy(&sin.sin_addr.s_addr, 4, outip);
+    sin.sin_family = AF_INET;
+
+    if (bind(s, (struct sockaddr *) &sin, sizeof(sin)) == -1) return -1;
+  }
+
   byte_zero(&sin,sizeof(sin));
   byte_copy(&sin.sin_addr,4,ip);
   x = (char *) &sin.sin_port;
Index: hier.c
===================================================================
--- hier.c	(.../trunk)	(Revision 1)
+++ hier.c	(.../branches/bulkmailer)	(Revision 29)
@@ -1,12 +1,21 @@
-#include "auto_qmail.h"
 #include "auto_split.h"
 #include "auto_uids.h"
 #include "fmt.h"
 #include "fifo.h"
 
+/* Fool auto_uids.o into pulling the uid/gid files from the subdirectory
+ * "owners" in the current directory.  This requires that the command
+ * "./make-owners ." be executed in the source directory before running
+ * qmail-hier.  This unfortunately hoses up the standard install process
+ * (it will install into the current directory instead of /var/qmail),
+ * and so it requires the install-path patch for proper operation.
+ */
+char auto_qmail[] = ".";
+
 char buf[100 + FMT_ULONG];
 
-void dsplit(base,uid,mode)
+void dsplit(auto_qmail,base,uid,mode)
+char *auto_qmail;
 char *base; /* must be under 100 bytes */
 int uid;
 int mode;
@@ -27,12 +36,26 @@
   }
 }
 
-void hier()
+void hier(auto_qmail)
+char *auto_qmail;
 {
+  get_uid(auto_uida);
+  get_uid(auto_uidd);
+  get_uid(auto_uidl);
+  get_uid(auto_uido);
+  get_uid(auto_uidp);
+  get_uid(auto_uidq);
+  get_uid(auto_uidr);
+  get_uid(auto_uids);
+
+  get_gid(auto_gidq);
+  get_gid(auto_gidn);
+
   h(auto_qmail,auto_uido,auto_gidq,0755);
 
   d(auto_qmail,"control",auto_uido,auto_gidq,0755);
   d(auto_qmail,"users",auto_uido,auto_gidq,0755);
+  d(auto_qmail,"owners",auto_uido,auto_gidq,0755);
   d(auto_qmail,"bin",auto_uido,auto_gidq,0755);
   d(auto_qmail,"boot",auto_uido,auto_gidq,0755);
   d(auto_qmail,"doc",auto_uido,auto_gidq,0755);
@@ -54,10 +77,12 @@
   d(auto_qmail,"queue/todo",auto_uidq,auto_gidq,0750);
   d(auto_qmail,"queue/bounce",auto_uids,auto_gidq,0700);
 
-  dsplit("queue/mess",auto_uidq,0750);
-  dsplit("queue/info",auto_uids,0700);
-  dsplit("queue/local",auto_uids,0700);
-  dsplit("queue/remote",auto_uids,0700);
+  dsplit(auto_qmail, "queue/mess",auto_uidq,0750);
+  dsplit(auto_qmail, "queue/todo",auto_uidq,0750);
+  dsplit(auto_qmail, "queue/intd",auto_uidq,0700);
+  dsplit(auto_qmail, "queue/info",auto_uids,0700);
+  dsplit(auto_qmail, "queue/local",auto_uids,0700);
+  dsplit(auto_qmail, "queue/remote",auto_uids,0700);
 
   d(auto_qmail,"queue/lock",auto_uidq,auto_gidq,0750);
   z(auto_qmail,"queue/lock/tcpto",1024,auto_uidr,auto_gidq,0644);
@@ -108,6 +133,9 @@
   c(auto_qmail,"bin","qmail-rspawn",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-clean",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-send",auto_uido,auto_gidq,0711);
+#ifdef EXTERNAL_TODO
+  c(auto_qmail,"bin","qmail-todo",auto_uido,auto_gidq,0711);
+#endif
   c(auto_qmail,"bin","splogger",auto_uido,auto_gidq,0711);
   c(auto_qmail,"bin","qmail-newu",auto_uido,auto_gidq,0700);
   c(auto_qmail,"bin","qmail-newmrh",auto_uido,auto_gidq,0700);
@@ -143,6 +171,7 @@
   c(auto_qmail,"bin","qail",auto_uido,auto_gidq,0755);
   c(auto_qmail,"bin","elq",auto_uido,auto_gidq,0755);
   c(auto_qmail,"bin","pinq",auto_uido,auto_gidq,0755);
+  c(auto_qmail,"bin","make-owners",auto_uido,auto_gidq,0755);
 
   c(auto_qmail,"man/man5","addresses.5",auto_uido,auto_gidq,0644);
   c(auto_qmail,"man/cat5","addresses.0",auto_uido,auto_gidq,0644);
Index: conf-spawn
===================================================================
--- conf-spawn	(.../trunk)	(Revision 1)
+++ conf-spawn	(.../branches/bulkmailer)	(Revision 29)
@@ -1,4 +1,4 @@
-120
+1000
 
 This is a silent concurrency limit. You can't set it above 255. On some
 systems you can't set it above 125. qmail will refuse to compile if the
Index: qmail-start.c
===================================================================
--- qmail-start.c	(.../trunk)	(Revision 1)
+++ qmail-start.c	(.../branches/bulkmailer)	(Revision 29)
@@ -8,6 +8,9 @@
 char *(qcargs[]) = { "qmail-clean", 0 };
 char *(qlargs[]) = { "qmail-lspawn", "./Mailbox", 0 };
 char *(qrargs[]) = { "qmail-rspawn", 0 };
+#ifdef EXTERNAL_TODO
+char *(qtargs[]) = { "qmail-todo", 0};
+#endif
 
 void die() { _exit(111); }
 
@@ -18,13 +21,28 @@
 int pi4[2];
 int pi5[2];
 int pi6[2];
+#ifdef EXTERNAL_TODO
+int pi7[2];
+int pi8[2];
+int pi9[2];
+int pi10[2];
+#endif
 
-void close23456() { close(2); close(3); close(4); close(5); close(6); }
+void close23456() { 
+  close(2); close(3); close(4); close(5); close(6); 
+#ifdef EXTERNAL_TODO
+  close(7); close(8);
+#endif
+}
 
 void closepipes() {
   close(pi1[0]); close(pi1[1]); close(pi2[0]); close(pi2[1]);
   close(pi3[0]); close(pi3[1]); close(pi4[0]); close(pi4[1]);
   close(pi5[0]); close(pi5[1]); close(pi6[0]); close(pi6[1]);
+#ifdef EXTERNAL_TODO
+  close(pi7[0]); close(pi7[1]); close(pi8[0]); close(pi8[1]);
+	close(pi9[0]); close(pi9[1]); close(pi10[0]); close(pi10[1]);
+#endif
 }
 
 void main(argc,argv)
@@ -40,6 +58,10 @@
   if (fd_copy(4,0) == -1) die();
   if (fd_copy(5,0) == -1) die();
   if (fd_copy(6,0) == -1) die();
+#ifdef EXTERNAL_TODO
+  if (fd_copy(7,0) == -1) die();
+  if (fd_copy(8,0) == -1) die();
+#endif
 
   if (argv[1]) {
     qlargs[1] = argv[1];
@@ -70,6 +92,12 @@
   if (pipe(pi4) == -1) die();
   if (pipe(pi5) == -1) die();
   if (pipe(pi6) == -1) die();
+#ifdef EXTERNAL_TODO
+  if (pipe(pi7) == -1) die();
+  if (pipe(pi8) == -1) die();
+  if (pipe(pi9) == -1) die();
+  if (pipe(pi10) == -1) die();
+#endif
  
   switch(fork()) {
     case -1: die();
@@ -105,6 +133,34 @@
       execvp(*qcargs,qcargs);
       die();
   }
+
+#ifdef EXTERNAL_TODO
+  switch(fork()) {
+    case -1: die();
+    case 0:
+      if (prot_uid(auto_uids) == -1) die();
+      if (fd_copy(0,pi7[0]) == -1) die();
+      if (fd_copy(1,pi8[1]) == -1) die();
+      close23456();
+      if (fd_copy(2,pi9[1]) == -1) die();
+      if (fd_copy(3,pi10[0]) == -1) die();
+      closepipes();
+      execvp(*qtargs,qtargs);
+      die();
+  }
+
+  switch(fork()) {
+    case -1: die();
+    case 0:
+      if (prot_uid(auto_uidq) == -1) die();
+      if (fd_copy(0,pi9[0]) == -1) die();
+      if (fd_copy(1,pi10[1]) == -1) die();
+      close23456();
+      closepipes();
+      execvp(*qcargs,qcargs);
+      die();
+  }
+#endif
  
   if (prot_uid(auto_uids) == -1) die();
   if (fd_copy(0,1) == -1) die();
@@ -114,6 +170,10 @@
   if (fd_copy(4,pi4[0]) == -1) die();
   if (fd_copy(5,pi5[1]) == -1) die();
   if (fd_copy(6,pi6[0]) == -1) die();
+#ifdef EXTERNAL_TODO
+  if (fd_copy(7,pi7[1]) == -1) die();
+  if (fd_copy(8,pi8[0]) == -1) die();
+#endif
   closepipes();
   execvp(*qsargs,qsargs);
   die();
Index: realrcptto.c
===================================================================
--- realrcptto.c	(.../trunk)	(Revision 0)
+++ realrcptto.c	(.../branches/bulkmailer)	(Revision 29)
@@ -0,0 +1,333 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <pwd.h>
+#include "auto_break.h"
+#include "auto_usera.h"
+#include "byte.h"
+#include "case.h"
+#include "cdb.h"
+#include "constmap.h"
+#include "error.h"
+#include "fmt.h"
+#include "open.h"
+#include "str.h"
+#include "stralloc.h"
+#include "uint32.h"
+#include "substdio.h"
+#include "env.h"
+
+extern void die_nomem();
+extern void die_control();
+extern void die_cdb();
+extern void die_sys();
+
+static stralloc envnoathost = {0};
+static stralloc percenthack = {0};
+static stralloc locals = {0};
+static stralloc vdoms = {0};
+static struct constmap mappercenthack;
+static struct constmap maplocals;
+static struct constmap mapvdoms;
+
+static char *dash;
+static char *extension;
+static char *local;
+static struct passwd *pw;
+
+/*
+static char errbuf[128];
+static struct substdio sserr = SUBSTDIO_FDBUF(write,2,errbuf,sizeof errbuf);
+
+static char pidbuf[64];
+static char remoteipbuf[64]=" ";
+*/
+
+static int flagchkrcpt;		/* if set check recipient in smtp stage */
+static int flagdenyall;
+static int flagdenyany;
+
+void realrcptto_init()
+{
+  char *x;
+
+  x = env_get("CHKRCPT");
+  flagchkrcpt = (x && x[0]=='1' && x[1]=='\0');
+
+  if (!flagchkrcpt) return;
+
+  if (control_rldef(&envnoathost,"control/envnoathost",1,"envnoathost") != 1)
+    die_control();
+
+  if (control_readfile(&locals,"control/locals",1) != 1) die_control();
+  if (!constmap_init(&maplocals,locals.s,locals.len,0)) die_nomem();
+  switch(control_readfile(&percenthack,"control/percenthack",0)) {
+    case -1: die_control();
+    case 0: if (!constmap_init(&mappercenthack,"",0,0)) die_nomem();
+    case 1:
+      if (!constmap_init(&mappercenthack,percenthack.s,percenthack.len,0))
+        die_nomem();
+  }
+  switch(control_readfile(&vdoms,"control/virtualdomains",0)) {
+    case -1: die_control();
+    case 0: if (!constmap_init(&mapvdoms,"",0,1)) die_nomem();
+    case 1: if (!constmap_init(&mapvdoms,vdoms.s,vdoms.len,1)) die_nomem();
+  }
+
+/*
+  str_copy(pidbuf + fmt_ulong(pidbuf,getpid())," ");
+  x=env_get("PROTO");
+  if (x) {
+    static char const remoteip[]="REMOTEIP";
+    unsigned int len = str_len(x);
+    if (len <= sizeof remoteipbuf - sizeof remoteip) {
+      byte_copy(remoteipbuf,len,x);
+      byte_copy(remoteipbuf + len,sizeof remoteip,remoteip);
+      x = env_get(remoteipbuf);
+      len = str_len(x);
+      if (len + 1 < sizeof remoteipbuf) {
+        byte_copy(remoteipbuf,len,x);
+        remoteipbuf[len]=' ';
+        remoteipbuf[len + 1]='\0';
+      }
+    }
+  }
+ */
+
+  x = env_get("QMAILRRTDENYALL");
+  flagdenyall = (x && x[0]=='1' && x[1]=='\0');
+}
+
+void realrcptto_start()
+{
+  if (!flagchkrcpt) return;
+
+  flagdenyany = 0;
+}
+
+static int denyaddr(addr)
+char *addr;
+{
+/* we do verbose logging in the receiving daemons
+  substdio_puts(&sserr,"realrcptto ");
+  substdio_puts(&sserr,pidbuf);
+  substdio_puts(&sserr,remoteipbuf);
+  substdio_puts(&sserr,addr);
+  substdio_putsflush(&sserr,"\n");
+ */
+  flagdenyany = 1;
+  return flagdenyall;
+}
+
+#define GETPW_USERLEN 32
+
+static int userext()
+{
+  char username[GETPW_USERLEN];
+  struct stat st;
+
+  extension = local + str_len(local);
+  for (;;) {
+    if (extension - local < sizeof(username))
+      if (!*extension || (*extension == *auto_break)) {
+	byte_copy(username,extension - local,local);
+	username[extension - local] = 0;
+	case_lowers(username);
+	errno = 0;
+	pw = getpwnam(username);
+	if (errno == error_txtbsy) die_sys();
+	if (pw)
+	  if (pw->pw_uid)
+	    if (stat(pw->pw_dir,&st) == 0) {
+	      if (st.st_uid == pw->pw_uid) {
+		dash = "";
+		if (*extension) { ++extension; dash = "-"; }
+		return 1;
+	      }
+	    }
+	    else
+	      if (error_temp(errno)) die_sys();
+      }
+    if (extension == local) return 0;
+    --extension;
+  }
+}
+
+int realrcptto(addr)
+char *addr;
+{
+  char *homedir;
+  static stralloc localpart = {0};
+  static stralloc lower = {0};
+  static stralloc nughde = {0};
+  static stralloc wildchars = {0};
+  static stralloc safeext = {0};
+  static stralloc qme = {0};
+  unsigned int i,at;
+
+  if (!flagchkrcpt) return 1;	/* don't check */
+
+  /* Short circuit, or full logging?  Short circuit. */
+  if (flagdenyall && flagdenyany) return 1;
+
+  /* qmail-send:rewrite */
+  if (!stralloc_copys(&localpart,addr)) die_nomem();
+  i = byte_rchr(localpart.s,localpart.len,'@');
+  if (i == localpart.len) {
+    if (!stralloc_cats(&localpart,"@")) die_nomem();
+    if (!stralloc_cat(&localpart,&envnoathost)) die_nomem();
+  }
+  while (constmap(&mappercenthack,localpart.s + i + 1,localpart.len - i - 1)) {
+    unsigned int j = byte_rchr(localpart.s,i,'%');
+    if (j == i) break;
+    localpart.len = i;
+    i = j;
+    localpart.s[i] = '@';
+  }
+  at = byte_rchr(localpart.s,localpart.len,'@');
+  if (constmap(&maplocals,localpart.s + at + 1,localpart.len - at - 1)) {
+    localpart.len = at;
+    localpart.s[at] = '\0';
+  } else {
+    unsigned int xlen,newlen;
+    char *x;
+    for (i = 0;;++i) {
+      if (i > localpart.len) return 1;
+      if (!i || (i == at + 1) || (i == localpart.len) ||
+          ((i > at) && (localpart.s[i] == '.'))) {
+        x = constmap(&mapvdoms,localpart.s + i,localpart.len - i);
+        if (x) break;
+      }
+    }
+    if (!*x) return 1;
+    xlen = str_len(x) + 1;  /* +1 for '-' */
+    newlen = xlen + at + 1; /* +1 for \0 */
+    if (xlen < 1 || newlen - 1 < xlen || newlen < 1 ||
+        !stralloc_ready(&localpart,newlen))
+      die_nomem();
+    localpart.s[newlen - 1] = '\0';
+    byte_copyr(localpart.s + xlen,at,localpart.s);
+    localpart.s[xlen - 1] = '-';
+    byte_copy(localpart.s,xlen - 1,x);
+    localpart.len = newlen;
+  }
+
+  /* qmail-lspawn:nughde_get */
+  {
+    int r,fd,flagwild;
+    if (!stralloc_copys(&lower,"!")) die_nomem();
+    if (!stralloc_cats(&lower,localpart.s)) die_nomem();
+    if (!stralloc_0(&lower)) die_nomem();
+    case_lowerb(lower.s,lower.len);
+    if (!stralloc_copys(&nughde,"")) die_nomem();
+    fd = open_read("users/cdb");
+    if (fd == -1) {
+      if (errno != error_noent) die_cdb();
+    } else {
+      uint32 dlen;
+      r = cdb_seek(fd,"",0,&dlen);
+      if (r != 1) die_cdb();
+      if (!stralloc_ready(&wildchars,(unsigned int) dlen)) die_nomem();
+      wildchars.len = dlen;
+      if (cdb_bread(fd,wildchars.s,wildchars.len) == -1) die_cdb();
+      i = lower.len;
+      flagwild = 0;
+      do { /* i > 0 */
+        if (!flagwild || (i == 1) ||
+            (byte_chr(wildchars.s,wildchars.len,lower.s[i - 1])
+             < wildchars.len)) {
+          r = cdb_seek(fd,lower.s,i,&dlen);
+          if (r == -1) die_cdb();
+          if (r == 1) {
+            char *x;
+            if (!stralloc_ready(&nughde,(unsigned int) dlen)) die_nomem();
+            nughde.len = dlen;
+            if (cdb_bread(fd,nughde.s,nughde.len) == -1) die_cdb();
+            if (flagwild)
+              if (!stralloc_cats(&nughde,localpart.s + i - 1)) die_nomem();
+            if (!stralloc_0(&nughde)) die_nomem();
+            close(fd);
+            x=nughde.s;
+            /* skip username */
+            x += byte_chr(x,nughde.s + nughde.len - x,'\0');
+            if (x == nughde.s + nughde.len) return 1;
+            ++x;
+            /* skip uid */
+            x += byte_chr(x,nughde.s + nughde.len - x,'\0');
+            if (x == nughde.s + nughde.len) return 1;
+            ++x;
+            /* skip gid */
+            x += byte_chr(x,nughde.s + nughde.len - x,'\0');
+            if (x == nughde.s + nughde.len) return 1;
+            ++x;
+            /* skip homedir */
+            homedir=x;
+            x += byte_chr(x,nughde.s + nughde.len - x,'\0');
+            if (x == nughde.s + nughde.len) return 1;
+            ++x;
+            /* skip dash */
+            dash=x;
+            x += byte_chr(x,nughde.s + nughde.len - x,'\0');
+            if (x == nughde.s + nughde.len) return 1;
+            ++x;
+            extension=x;
+            goto got_nughde;
+          }
+        }
+        --i;
+        flagwild = 1;
+      } while (i);
+      close(fd);
+    }
+  }
+
+  /* qmail-getpw */
+  local = localpart.s;
+  if (!userext()) {
+    extension = local;
+    dash = "-";
+    pw = getpwnam(auto_usera);
+  }
+  if (!pw) return denyaddr(addr);
+  if (!stralloc_copys(&nughde,pw->pw_dir)) die_nomem();
+  if (!stralloc_0(&nughde)) die_nomem();
+  homedir=nughde.s;
+
+  got_nughde:
+
+  /* qmail-local:qmesearch */
+  if (!*dash) return 1;
+  if (!stralloc_copys(&safeext,extension)) die_nomem();
+  case_lowerb(safeext.s,safeext.len);
+  for (i = 0;i < safeext.len;++i)
+    if (safeext.s[i] == '.')
+      safeext.s[i] = ':';
+  {
+    struct stat st;
+    int i;
+    if (!stralloc_copys(&qme,homedir)) die_nomem();
+    if (!stralloc_cats(&qme,"/.qmail")) die_nomem();
+    if (!stralloc_cats(&qme,dash)) die_nomem();
+    if (!stralloc_cat(&qme,&safeext)) die_nomem();
+    if (!stralloc_0(&qme)) die_nomem();
+    if (stat(qme.s, &st) == 0 || errno != error_noent) return 1;
+    for (i = safeext.len;i >= 0;--i)
+      if (!i || (safeext.s[i - 1] == '-')) {
+        if (!stralloc_copys(&qme,homedir)) die_nomem();
+        if (!stralloc_cats(&qme,"/.qmail")) die_nomem();
+        if (!stralloc_cats(&qme,dash)) die_nomem();
+        if (!stralloc_catb(&qme,safeext.s,i)) die_nomem();
+        if (!stralloc_cats(&qme,"default")) die_nomem();
+        if (!stralloc_0(&qme)) die_nomem();
+        if (stat(qme.s, &st) == 0 || errno != error_noent) return 1;
+      }
+    return denyaddr(addr);
+  }
+}
+
+int realrcptto_deny()
+{
+  if (!flagchkrcpt) return 0;
+
+  return flagdenyall && flagdenyany;
+}
Index: qmail.7
===================================================================
--- qmail.7	(.../trunk)	(Revision 1)
+++ qmail.7	(.../branches/bulkmailer)	(Revision 29)
@@ -55,12 +55,14 @@
 and
 .BR qmail-pop3d (8).
 
-This documentation describes version
-1.03
+This documentation describes netqmail version
+1.05
 of
 .BR qmail .
 See
 .B http://pobox.com/~djb/qmail.html
 for other
 .BR qmail -related
-software.
+software, and
+.B http://qmail.org/
+for other qmail community contributions.
Index: qmail-local.c
===================================================================
--- qmail-local.c	(.../trunk)	(Revision 1)
+++ qmail-local.c	(.../branches/bulkmailer)	(Revision 29)
@@ -645,7 +645,7 @@
     {
      cmds.s[j] = 0;
      k = j;
-     while ((k > i) && (cmds.s[k - 1] == ' ') || (cmds.s[k - 1] == '\t'))
+     while ((k > i) && ((cmds.s[k - 1] == ' ') || (cmds.s[k - 1] == '\t')))
        cmds.s[--k] = 0;
      switch(cmds.s[i])
       {
